# Makefile for ~lp/bin/solaris/prod

# This is the same as the makefile for sparc/prod, except that the cc optimizer
# is turned off because it does not handle CLU resignalling properly

PLATFORM   = solaris
MODE	   = prod
CLU        = ${CLUHOME}/exe/pclu
CLU_MSG    = Optimizing
CLU_LOCALS = false
CLU_OPT    =
LP_LIB 	   = lp.lib
PLINK	   = ${CLUHOME}/exe/plink
PL_FLAGS   = -opt

REL	   = lp3.1
BIN	   = ../..
CODE	   = ../../../code
LP_MAKE	   = ../../makefiles/${PLATFORM}.${MODE}
SDIRS      = genlib logic main names ordering parsing satisfier terms unify
SPECIAL    = ${CODE}/main/version.clu ${CODE}/genlib/interrupt.clu


# Definitions of source and object files (generated by "make Makefile")
SOURCE_MAKES = ../../../code/genlib/Makefile ../../../code/logic/Makefile ../../../code/main/Makefile ../../../code/names/Makefile ../../../code/ordering/Makefile ../../../code/parsing/Makefile ../../../code/satisfier/Makefile ../../../code/terms/Makefile ../../../code/unify/Makefile 
CLU_EQUATES  = Debugging.equ Echo.equ Genlib.equ Logic.equ Names.equ Ordering.equ Parsing.equ Query.equ Satisfier.equ Terms.equ Unify.equ ZMain.equ 
CLU_SOURCES  = TheoryB.clu TheoryE.clu TheoryR.clu abort.clu ac_unify.clu add_num_theory_hack.clu array_seq.clu assign.clu axiom_system.clu c_apply.clu c_assert.clu c_box.clu c_cancel.clu c_class.clu c_clear.clu c_complete.clu c_critical.clu c_declare.clu c_delete.clu c_diamond.clu c_display.clu c_execute.clu c_fix.clu c_forget.clu c_freeze.clu c_help.clu c_history.clu c_instantiate.clu c_make.clu c_normalize.clu c_order.clu c_pop.clu c_prove.clu c_push.clu c_qed.clu c_quit.clu c_register.clu c_resume.clu c_rewrite.clu c_set.clu c_show.clu c_statistics.clu c_stop.clu c_thaw.clu c_unify.clu c_unorder.clu c_unregister.clu c_unset.clu c_version.clu c_write.clu c_zap.clu check_end.clu class_expression.clu class_table.clu clause.clu clauses.clu collection.clu combinator.clu commands.clu comparison.clu comtable.clu convert.clu critical.clu deb.clu deduction_rule.clu deduction_system.clu diophan.clu dsmpos.clu dsmpos_ord.clu dsmpos_sug.clu egraph.clu either_way_ord.clu elimination.clu embed.clu empt_unify.clu equation_system.clu expression.clu extend.clu fact.clu failure.clu file.clu flatten.clu formula.clu front_end.clu generic.clu ground_system.clu hardwired_drs.clu hardwired_ids.clu hardwired_ots.clu hardwired_rrs.clu hash_table.clu home_directory.clu hullot.clu id_table.clu identifier.clu induction_rule.clu induction_system.clu integer.clu interactive.clu interrupt.clu iodev.clu keyed_mapping.clu keyword_table.clu l2r_ord.clu linked.clu list.clu literal.clu literals.clu man_ord.clu mapping.clu match.clu matrix.clu miscellany.clu model.clu multiset.clu my_int.clu my_matrix.clu my_queue.clu my_terms.clu name.clu name_range.clu name_set.clu ninteractive.clu num_theory.clu op_system.clu op_theory.clu operator.clu ord_commands.clu ordering.clu overlaps.clu p_graph.clu pdeduction_rule.clu permute.clu pfact.clu pformula.clu pinduction_rule.clu plh_eqn.clu poly.clu poly_ord.clu pop_theory.clu poperator.clu precedence.clu printer.clu proposition.clu prover.clu psignature.clu psort.clu psubstitution.clu pterm.clu pvariable.clu quant_unify.clu quantifier.clu query.clu queue.clu rat.clu rat_arr.clu registry.clu relation.clu rewriting_system.clu rrp_table.clu satisfy.clu scanner.clu set.clu settings.clu signals.clu signature.clu simplex.clu solution.clu sort.clu stack.clu start_up.clu statistics.clu string_int.clu substitution.clu subterm_graph.clu symtab.clu system.clu tableau.clu term.clu term_space.clu theory.clu theory_system.clu token.clu tracer.clu undo_arr.clu undo_set.clu unify.clu unknown.clu unknowns.clu unpterm.clu var_gen.clu variable.clu version.clu 
C_OBJECTS    = TheoryB.o TheoryE.o TheoryR.o abort.o ac_unify.o add_num_theory_hack.o array_seq.o assign.o axiom_system.o c_apply.o c_assert.o c_box.o c_cancel.o c_class.o c_clear.o c_complete.o c_critical.o c_declare.o c_delete.o c_diamond.o c_display.o c_execute.o c_fix.o c_forget.o c_freeze.o c_help.o c_history.o c_instantiate.o c_make.o c_normalize.o c_order.o c_pop.o c_prove.o c_push.o c_qed.o c_quit.o c_register.o c_resume.o c_rewrite.o c_set.o c_show.o c_statistics.o c_stop.o c_thaw.o c_unify.o c_unorder.o c_unregister.o c_unset.o c_version.o c_write.o c_zap.o check_end.o class_expression.o class_table.o clause.o clauses.o collection.o combinator.o commands.o comparison.o comtable.o convert.o critical.o deb.o deduction_rule.o deduction_system.o diophan.o dsmpos.o dsmpos_ord.o dsmpos_sug.o egraph.o either_way_ord.o elimination.o embed.o empt_unify.o equation_system.o expression.o extend.o fact.o failure.o file.o flatten.o formula.o front_end.o generic.o ground_system.o hardwired_drs.o hardwired_ids.o hardwired_ots.o hardwired_rrs.o hash_table.o home_directory.o hullot.o id_table.o identifier.o induction_rule.o induction_system.o integer.o interactive.o interrupt.o iodev.o keyed_mapping.o keyword_table.o l2r_ord.o linked.o list.o literal.o literals.o man_ord.o mapping.o match.o matrix.o miscellany.o model.o multiset.o my_int.o my_matrix.o my_queue.o my_terms.o name.o name_range.o name_set.o ninteractive.o num_theory.o op_system.o op_theory.o operator.o ord_commands.o ordering.o overlaps.o p_graph.o pdeduction_rule.o permute.o pfact.o pformula.o pinduction_rule.o plh_eqn.o poly.o poly_ord.o pop_theory.o poperator.o precedence.o printer.o proposition.o prover.o psignature.o psort.o psubstitution.o pterm.o pvariable.o quant_unify.o quantifier.o query.o queue.o rat.o rat_arr.o registry.o relation.o rewriting_system.o rrp_table.o satisfy.o scanner.o set.o settings.o signals.o signature.o simplex.o solution.o sort.o stack.o start_up.o statistics.o string_int.o substitution.o subterm_graph.o symtab.o system.o tableau.o term.o term_space.o theory.o theory_system.o token.o tracer.o undo_arr.o undo_set.o unify.o unknown.o unknowns.o unpterm.o var_gen.o variable.o version.o 
# End of definitions

RM	= /bin/rm -f
MV	= /bin/mv
LN	= /bin/ln -s
TR	= /usr/bin/tr '\012' '\040'
STRIP	= strip


# Make commands

.SUFFIXES:
.SUFFIXES: .o .clu

.clu.o:
	@echo compile $? >> .new-clu-sources

all: Makefile init compile lp

Makefile: ${LP_MAKE} .sources .equates .objects .smakefiles
	sed -n -e "1,/Definitions/p" ${LP_MAKE} 	 > Makefile
	echo "SOURCE_MAKES = `${TR} < .smakefiles`"	>> Makefile
	echo "CLU_EQUATES  = `${TR} < .equates`" 	>> Makefile
	echo "CLU_SOURCES  = `${TR} < .sources`" 	>> Makefile
	echo "C_OBJECTS    = `${TR} < .objects`" 	>> Makefile
	sed -n -e "/End of def/,$$$$p" ${LP_MAKE} 	>> Makefile

.sources .equates: ${SOURCE_MAKES} ${LP_MAKE}
	${RM} *.equ *.clu .sources .equates
	for d in ${SDIRS}; do make -f ${CODE}/$$d/Makefile link; done
	for f in ${SPECIAL}; do ${LN} $$f .; done
	ls *.clu > .sources
	ls *.equ > .equates

.smakefiles:
	${RM} .smakefiles
	for f in ${SDIRS}; do echo ${CODE}/$$f/Makefile >> .smakefiles; done

.objects: .sources
	sed -e "/\.clu/s//\.o/g" .sources > .objects


# Entries for ~lp/bin/<platform>/prod to generate lp.lib

# It is necessary to remake lp.lib explicitly each time an interface changes.
# The makefile doesn't do this automatically (by having *.clu depend on lp.lib)
# because we don't want to remake lp.lib everytime we change a .clu file.

# To remake lp.lib after adding a new interface, it is generally sufficient
# (and twice as fast) to type "make libpass".

lp.lib:	${CLU_SOURCES} ${CLU_EQUATES} lib.xfile
	make libpass P=1 MRGLIB=~CLU/lib/*.lib
	make libpass P=2 MRGLIB=${LP_LIB}

P      = 2
MRGLIB = ${LP_LIB}

libpass: lib.xfile
	@echo "Making lp.lib for ${PLATFORM}, pass $P"
	${CLU} \#me ${MRGLIB} \#xfile lib > .clu-errors
	-@echo `egrep -c ":[^0-9]"\|Undefined .clu-errors` > .errors
	@if test $P -eq 2;						      \
	    then if test `cat .errors` -gt 0;				      \
	            then echo "Check `pwd`/.clu-errors for interface errors"; \
		         touch lib.xfile;				      \
	            else echo "Interface specification finished";	      \
	                 ${RM} .clu-errors;				      \
	            fi;							      \
	    else true;							      \
	    fi

lib.xfile: .equates .sources
	echo "externals false"			> lib.xfile
	echo "ce `${TR} < .equates`"		>> lib.xfile
	for f in `cat .sources`;					      \
	    do echo "spec $$f" >> lib.xfile;		      		      \
	    done
	echo "du ${LP_LIB}"			>> lib.xfile

init:
	@${RM} .new-clu-sources

# The dependency on ${C_OBJECTS} adds file names to .new-clu-sources.

compile: ${C_OBJECTS}
	@if test -f ${LP_LIB} -o ! -s .new-clu-sources; then true;	      \
            else echo "First make lp.lib"; false;	 		      \
            fi
	if test -s .new-clu-sources;					      \
	    then echo ${CLU_MSG} `sed -e "/^compile /s///" .new-clu-sources`; \
		 ${CLU} \#me ${LP_LIB} 				   	      \
	    		\#externals false				      \
	    		\#locals ${CLU_LOCALS}				      \
	    		\#optimize ${CLU_OPT}				      \
	    		\#ce ${CLU_EQUATES}				      \
	    		\#xfile .new-clu-sources			      \
	    		\^.clu-errors;					      \
		 echo "Done compiling clu sources";			      \
	    else echo "" >  .clu-errors;				      \
            fi
	-@echo `egrep -c ":[^0-9]"\|Undefined .clu-errors` > .errors
	@if test `cat .errors` -gt 0; 				 	      \
	    then echo "Check `pwd`/.clu-errors for compilation errors.";      \
                 false;							      \
	    else true;					                      \
	    fi

lp: ${C_OBJECTS}
	@echo "Linking `pwd`/lp"
	${PLINK} ${PL_FLAGS} -o lp ${C_OBJECTS}

install: lp
	${CP} lp ${BIN}/${REL}.${PLATFORM}
	${STRIP} ${BIN}/${REL}.${PLATFORM}
	${RM} ${BIN}/lp
	${LN} ${REL}.${PLATFORM} ${BIN}/lp

tidy:
	${RM} *.old *.ckp *.bak ,* *~ \#*\# .*.old .*.ckp .*.bak .*~ core
	${RM} .new* *_b_ *_c_ clu.junk

clean: tidy
	${RM} *.equ *.clu .sources .equates .objects .smakefiles
	${RM} *.lp* lp* lib.xfile *.o
