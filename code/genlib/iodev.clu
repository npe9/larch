#extend

% An "iodev" handles input from, and output to, an interactive input/output
% device.  It provides features for making scripts from input, for replaying
% scripts, for logging all input and output, for pausing between pages of
% output, and for communicating with other processes.

% A request for input via "iodev$gets" gets a string (terminated by specified
% characters) from the current line of input; if no input remains on the
% current line, a specified prompt is printed and a new line of input is
% obtained.  A request for input via "iodev$getl" gets the next line of input,
% or the remainder of the current line if it has not been completely consumed
% by "iodev$gets".

% CLU provides the following editing capabilities for lines of terminal input:
% 	<delete>  	deletes last character typed
% 	^L		clears screen and redisplays current line
% 	^R		redisplays current line
% 	^U		deletes current line
% 	^W		deletes last word on line
% 	^X<		like ^U, but starts a new blank line
% 	^\		line continuation

% FIX:  Problems with multiline input

%      INPUT				SCRIPT SHOULD BE

% (1)  good-command; bad-command	good-command
%					%% bad-command

% (2)  prove ...; []; qed		prove ...
%					  [] generated by LP
%					qed

% (3)  set name;foo			set name;foo

% (4)  set name;;foo			set name;
%					%% foo

% (5)  execute F; good-command		%% execute F
%					...
%					%% end of F
%					good-command

iodev = cluster is 
	new, add_log, add_script, close, comment_out_command, commit_command, 
	end_of_line_check, error, flush, get_command_prompt, get_history, 
	get_history_setting, getl, get_line_length, get_log_name, 
	get_page_mode, gets, get_script_name, get_total_lines, interrupt, 
	pending_input, printl, prints, push_back, putl, puts, putspace, 
	put_table, qprintl, qprints, read_script, reading_script, rem_log, 
	rem_script, reset_script_indent, restart_output, set_command_prompt, 
	set_comment_char, set_communication, set_history, set_history_setting, 
	set_line_break, set_page_mode, set_script_indent, set_testing_mode, 
	signalled, stop_reading_script, strike_script, valid_for_script,
	write_script
	

    % The "output" from an "iodev" is the primary output stream.  The
    % "line_length" is that of the underlying stream, or "default_line_length"
    % if the underlying stream has no limit.  The "page_size" is the number of
    % lines that fit on the display.  The "lines_on_page" is the number of
    % lines printed since the last interaction; "total_lines" is the total
    % number of lines output.  The "column" is the column of the line in which
    % the next character will be printed.

    % The "input" to an "iodev" is a stack of records, each of which contains
    % an input stream and a string of characters read from that stream, but not
    % yet consumed by the "get" operation.  The primary input is on the bottom
    % of the stack and some number of script files, which are being inserted in
    % the primary input, on top.  Input is read from the stream on top of the
    % "input" stack a line at a time into the "pending" component of the rep,
    % thereby enabling local editing of lines from the primary input.  The
    % "pending" component of the rep is copied into the input stack when a new
    % record is pushed on the stack, and is restored from the input stack when
    % the stack is popped.  All characters starting with the first
    % "comment_char" in an input line are discarded.  Any remaining
    % "line_break" characters in an input line are replaced by newlines.  Input
    % is echoed to the primary output if the size of the input stack is between
    % 2 and "echoing", inclusive.
    
    % All input and output is recorded in the "log" stream, if it exists.  All
    % input is also recorded in the "script" stream, if it exists, as follows.

    % Each call of "gets" with an empty "prompt" is deemed to start a new
    % command, with the "command_prompt" being used in place of the empty
    % "prompt".  All lines of input (including comments) since the start of the
    % last command are retained in "current_command_lines", except for lines
    % that begin with two comment delimiters, which are discarded.  (This keeps
    % lines that are commented out by this cluster from reappearing in a
    % script.)

    % Each time a new command begins, these lines are written to the "script"
    % stream, if it exists, with "script_indent" spaces at the beginning of the
    % first line and the remaining lines indented relative to the first.  If
    % "error_in_command" is true, these lines are prefaced by two comment
    % delimiters before being written to the script stream.

    % Recent input, corresponding the last "history_size" commands, is also
    % saved in "history", which is a bounded buffer, unless "history_size" is
    % -1, in which case "history" is an unbounded buffer.  The "command_id"
    % stack indicates how many commands have started on each of the streams on
    % the "input" stack.
    
    % Each time a new line of input is required from the primary input, the
    % "input_request" string is sent to the primary output, thereby notifying
    % any process watching the primary output stream that input is required.
    % Furthermore, each time a new line of input is required from any source,
    % the "handle_signal" procedure is invoked if "signal()" is true.  To
    % enable a signal to be detected even when this cluster is waiting for
    % input, a process supplying input to the primary input stream can send a
    % line consisting of a nonempty "null_response" string, which causes
    % "stream$getl" to return and is then discarded by this cluster.

    rep = record[column: int,
    		 command_id: int_arr, 
		 command_prompt: string,
		 comment_char: char,
		 current_command_lines: string_arr,
		 default_page_size: page_size,
		 echoing: int,
		 error_in_command: bool,
		 handle_signal: proctype (),
		 history: command_arr,
		 history_size: int,
		 input: input_arr,
		 input_request: string,
		 line_break: char,
		 line_length: int,
		 lines_on_page: int,
		 log: script,
		 null_response: string,
		 output: stream,
		 page_size: page_size,
		 pending: string,
		 script: script,
		 script_indent: int,
		 script_indent_prev: int,
		 total_lines: int]
    script = oneof[exists: stream, none: null]
    input_arr = array[input_rec]
    input_rec = record[source: stream, pending: string]
    page_size = oneof[num: int, infinite, invisible: null]
    
    default_line_length = 80


    % There is only one "iodev".

    own the_iodev: rep :=
	    rep${column: 1,
	         command_id: int_arr$[0],
		 command_prompt: initial_command_prompt,
		 comment_char: '\n',
		 current_command_lines: string_arr$[],
		 default_page_size: page_size$make_infinite(nil),
		 echoing: 1,
		 error_in_command: false,
		 handle_signal: no_op,
		 history: command_arr$[],
		 history_size: 0,
		 input: input_arr$[input_rec${source: stream$primary_input(),
		 			      pending: ""}],
		 input_request: "",
		 line_break: '\n',
		 line_length: default_line_length,
		 lines_on_page: 0,
		 log: script$make_none(nil),
		 null_response: "",
		 output: stream$primary_output(),
		 page_size: page_size$make_infinite(nil),
		 pending: "",
		 script: script$make_none(nil),
		 script_indent: 0,
		 script_indent_prev: 0,
		 total_lines: 0}

		 
    % A boolean variable that prevents termination of script files when testing
    % (so that error detection can be tested using a script).

    own testing: bool := false

    % (Internal procedure) A null procedure, used when no signals are expected.
    
    no_op = proc ()
	end no_op

    
    % Returns the only "iodev" there is.

    new = proc () returns (cvt)
	OS_init_interrupt()
	the_iodev.line_length := the_iodev.output.line_length
	   except when no_limit: end
	istr: stream := input_arr$bottom(the_iodev.input).source
	% Disable ^D as terminal end-of-file signal
	istr.eof_flag := false
	   except when not_possible (*): end
	return(the_iodev)
	end new


    % Adds the file named "fn" as a log stream to "io".  After this operation,
    % all input from and output to "io" (except for "more" prompts generated by
    % "puts" and responses to these prompts) is also written to this file until
    % "io" is closed or "rem_log(io)" is called.  Signals "already_logging" if
    % "io" is currently being logged.  Signals "already_in_use" if "fn" is
    % already being used for scripting or as a source of input.  Signals
    % "not_possible" if "fn" cannot be written.

    add_log = proc (io: cvt, fn: file_name) 
		signals (already_in_use, already_logging,
		         not_possible(string))
	if script$is_exists(io.log) then signal already_logging end
	io.log := script$make_exists(open_output(io, fn))
	   resignal already_in_use, not_possible
	end add_log


    % Adds the file named "fn" as a script stream to "io".  After this
    % operation, all input from "io" (except for responses to "more" prompts
    % generated by "puts") is also written to this file until "io" is closed or
    % "rem_script(io)" is called.  Signals "already_scripting" if input from
    % "io" is currently being scripted.  Signals "already_in_use" if "fn" is
    % currently being used for logging or as a source of input.  Signals
    % "not_possible" if "fn" cannot be written.

    add_script = proc (io: cvt, fn: file_name) 
		   signals (already_in_use, already_scripting, 
		            not_possible(string))
	if script$is_exists(io.script) then signal already_scripting end
	io.script := script$make_exists(open_output(io, fn))
	   resignal already_in_use, not_possible
	end add_script

    
    % (Internal procedure) Signals "already_in_use" if "fn" is already in use
    % for logging, scripting, or as a source of input.  Otherwise, opens "fn"
    % for "write" access and returns the resulting stream.  Signals
    % "not_possible" if "fn" cannot be written.
    
    open_output = proc (io: rep, fn: file_name) returns (stream)
		    signals (already_in_use, not_possible(string))
	s: stream := stream$open(fn, "read")
	   except when not_possible (*): return(stream$open(fn, "write"))
					    resignal not_possible
		  end
	if in_use(io, s) then
	   stream$close(s)
	   signal already_in_use
	   end
	stream$close(s)
	return(stream$open(fn, "write"))
	   resignal not_possible
	end open_output
    

    % (Internal procedure) Returns "true" if "fn" is already in use
    % for logging, scripting, or as a source of input.

    in_use = proc (io: rep, s: stream) returns (bool)
	for ir: input_rec in input_arr$elements(io.input) do
	    if s.name = ir.source.name then return(true) end
	       except when not_possible (*): end
	    end
	if s.name = script$value_exists(io.script).name then return(true) end
	   except when wrong_tag, not_possible (*): end
	return(s.name = script$value_exists(io.log).name)
	   except when wrong_tag, not_possible (*): end
	return(false)
	end in_use


    % Closes "io", and also its script and log streams, if they exist.

    close = proc (io: iodev)
	commit_command(io)	% Flush last command to script file
	while true do stop_reading_script(io, false) end 
	   except when no_script: end
	rem_script(io)
	   except when not_scripting: end
	rem_log(io)
	   except when not_logging: end
	end close


    % Turns all lines in "io.current_command_lines" into comments.
    
    comment_out_command = proc (io: cvt)
	for n: int in string_arr$indexes(io.current_command_lines) do
	    io.current_command_lines[n] := 
		comment_out(io, "", io.current_command_lines[n])
	    end
	end comment_out_command

    
    % Flushes "io.current_command_lines" to "io.history" and to "io.script".

    commit_command = proc (io: cvt)
	cr: command_record
	cr_exists: bool := false
	if io.history_size ~= 0 
	     cand ~string_arr$empty(io.current_command_lines) then
	   cr_exists := true
	   cr := command_record${id: command_id(io), command: ""}
	   command_arr$addh(io.history, cr)
	   if io.history_size > 0 then
	      while command_arr$size(io.history) > io.history_size do
		  command_arr$reml(io.history)
		  end
	      end
	   end
	adjust_command_lines(io.current_command_lines, io.script_indent_prev)
	io.script_indent_prev := io.script_indent  % CLEANUP: Is "prev" needed
	for s: string in string_arr$elements(io.current_command_lines) do
	    if io.error_in_command then s := comment_out(io, "ERROR: ", s) end
	    begin
		str: stream := script$value_exists(io.script)
		stream$putl(str, s)
		stream$flush(str)
		end except when wrong_tag: end
	    if cr_exists then cr.command := cr.command || s || "\n" end
	    end
	io.error_in_command := false
	io.current_command_lines := string_arr$[]
	end commit_command

    
    % Returns if no input remains on the current line.  Otherwise invokes
    % "error" and signals "excess(s)", where "s" is the string of characters
    % remaining on the line with tabs replaced by spaces.
    
    end_of_line_check = proc (io: iodev) signals (excess(string))
	if ~pending_input(io) then return end
	excess: string := trim_head(detab(getl(io)))
	if string$empty(excess) then return end
	error(io)
	signal excess(excess)
	end end_of_line_check

    
    % Closes all script streams on the stack for "io", thereby causing further
    % input from "io" to be read from the primary input.  Discards any
    % multiline input that may be pending.  Sets "io.error_in_command" true;
    % rings a bell if it was not already true.
    
    % FIX: We don't want to comment out parts of the current command lines
    % that have already been executed successfully.

    error = proc (io: cvt)
	bell = "\007"
	restart_output(up(io))
	if ~testing cand reading_script(up(io)) then
	   io.echoing := input_arr$size(io.input)
	   while true do stop_reading_script(up(io), true) end
	   end except when no_script: end
        if ~testing then io.pending := "" end
	if ~io.error_in_command then stream$puts(io.output, bell) end
        io.error_in_command := true
	end error
    

    % Flushes output to "io.output".
    
    flush = proc (io: cvt)
	stream$flush(io.output)
	end flush
    

    % Returns prompt used by "gets" for new commands.
    
    get_command_prompt = proc (io: cvt) returns (string)
	return(io.command_prompt)
	end get_command_prompt


    % Returns a copy of "io.history".

    get_history = proc (io: cvt) returns (command_arr)
	hist: command_arr := command_arr$copy(io.history)
	cr: command_record := command_record${id: command_id(io), command: ""}
	command_arr$addh(hist, cr)
	current: string_arr := string_arr$copy(io.current_command_lines)
	adjust_command_lines(current, io.script_indent_prev)
	for s: string in string_arr$elements(current) do
	    if io.error_in_command then s := comment_out(io, "ERROR: ", s) end
	    cr.command := cr.command || s || "\n"
	    end
	return(hist)
	end get_history


    % Gets the number of commands remembered in the history of "io".

    get_history_setting = proc (io: cvt) returns (int)
	return(io.history_size)
	end get_history_setting


    % Returns an input line from "io", with comments stripped and lines broken
    % at "io.line_break" characters.  Signals "end_of_file" if no lines remain.

    getl = proc (io: cvt) returns (string) signals (end_of_file)
	if string$empty(io.pending) then get_new_line(io) end
	   resignal end_of_file
	line, delim, rest: string := string_divide(io.pending, "\n")
	io.pending := rest
	return(line)
	end getl


    % Returns the line length of the underlying output stream, if it exists; 
    % otherwise returns a default length of 80.

    get_line_length = proc (io: cvt) returns (int)
	return(io.line_length)
	end get_line_length


    % Returns the name of the log file for "io".  Signals "none" if there is
    % no log file.

    get_log_name = proc (io: cvt) returns (string) signals (none)
	tagcase io.log
	   tag exists (s: stream): return(file_name$unparse(s.name))
	   tag none: signal none
	   end
	end get_log_name
    
    
    % Returns "true" if "io" is in page mode.

    get_page_mode = proc (io: cvt) returns (bool)
	tagcase io.default_page_size
	   tag num: return(true)
	   others: return(false)
	   end
	end get_page_mode


    % Starts a new command, and replaces "prompt" by "io.command_prompt", if
    % "prompt" is the empty string.  Outputs "prompt" if "io.pending" is empty.
    % Then discards leading spaces and tabs from "io.input", extracts the
    % string in "io.input" that precedes whichever comes first of a character 
    % in "delims", a newline, or the end of the file, again discards leading
    % spaces and tabs from "io.input", and returns the string.

    % ENHANCE: Signal error if there is pending input when "prompt" is null?
    % CLEAN UP: Combine common code with get_newline.
    
    gets = proc (io: cvt, prompt, delims: string) returns (string)
	head, delim, tail: string
	while true do
	    io.pending := trim_head(io.pending)
	    if io.pending[1] ~= '\n' then break end
	    io.pending := string$rest(io.pending, 2)
	    i: int := string$indexc('\n', io.pending)
	    if i > 1 then
	       if string$empty(prompt) then
		  commit_command(up(io))
		  n: int := int_arr$size(io.command_id)
		  io.command_id[n] := io.command_id[n] + 1
		  end
	       newline: string := string$substr(io.pending, 1, i-1)
	       tail := string$rest(io.pending, i)
	       newline := trim_tail(detab(newline))
	       n: int := input_arr$size(io.input)
	       if n <= io.echoing then
		  if 1 < n
		     then putl(up(io), newline)
			  io.column := 1
		     else stream$putl(script$value_exists(io.log), newline)
		     end except when wrong_tag: end
		  end
	       string_arr$addh(io.current_command_lines, newline)
	       m: int := string$indexc(io.comment_char, newline)
	       if m > 0 then newline := string$substr(newline, 1, m-1) end
	       io.pending := newline || tail
	       end
	    end except when bounds: end
	if string$empty(io.pending) then
	   while reading_script(up(io)) do
	       ir: input_rec := input_arr$top(io.input)
	       if ir.pending ~= "" cor ~stream$empty(ir.source) then break end
	       stop_reading_script(up(io), false)
	       end
	   end
	if string$empty(io.pending) then
	   if string$empty(prompt) then
	      commit_command(up(io))
	      n: int := int_arr$size(io.command_id)
	      io.command_id[n] := io.command_id[n] + 1
	      prompt := io.command_prompt
	      head, delim, tail := string_divide(prompt, "!")
	      if ~string$empty(delim) then
		 prompt := head || command_id(io) || tail
		 end
	      end
	   prints(up(io), prompt)
	   % Make room for response, if necessary.
	   if io.column > (3*io.line_length)/4 then puts(up(io), "\n") end
	   get_new_line(io)
	   io.pending := trim_head(io.pending)
	   end
	head, delim, tail := string_divide(io.pending, delims || "\n")
	io.pending := trim_head(tail)
        if (delim = " " cor delim = "\t") 
	     cand string$indexc(io.pending[1], delims) = 1 then
	   io.pending := trim_head(string$rest(io.pending, 2))
	   end
	if io.pending = "\n" then io.pending := "" end
	return(head)
	end gets


    % Returns the name of the script file for "io".  Signals "none" if there is
    % no script file.

    get_script_name = proc (io: cvt) returns (string) signals (none)
	tagcase io.script
	   tag exists (s: stream): return(file_name$unparse(s.name))
	   tag none: signal none
	   end
	end get_script_name

    
    % Returns the total number of lines output to "io.output".
    
    get_total_lines = proc (io: cvt) returns (int)
	return(io.total_lines)
	end get_total_lines
    

    % Returns "true" iff a QUIT has been typed by the user since the last call
    % to this procedure.

    interrupt = proc () returns (bool)
	return(OS_check_interrupt())
	end interrupt


    % Returns "true" iff there is pending input, i.e., iff some of the current
    % input line remains unread.

    pending_input = proc (io: cvt) returns (bool)
	s: string := trim_head(io.pending)
	return(s[1] ~= '\n')
	   except when bounds: return(false) end
	end pending_input


    % The "print" procedures are the same as the "put" procedures, except that
    % they insert newlines appropriately to keep the length of lines of output
    % from exceeding "io.line_length".  The procedures signal "contain_tabs" if
    % the output strings contain tabs.

    printl = proc (io: cvt, s: string) signals (contains_tabs)
	putl(up(io), string_split_lines(s, io.line_length, io.column-1))
	   resignal contains_tabs
	end printl

    prints = proc (io: cvt, s: string) signals (contains_tabs)
	puts(up(io), string_split_lines(s, io.line_length, io.column-1))
	   resignal contains_tabs
	end prints

    
    % Pushes "s" back into the pending input for the current input line.
    % Useful if we've taken a wrong parsing path.  ASSUMES: "s" does not
    % contain comment characters or line break characters.

    push_back = proc (io: cvt, s: string)
	io.pending := s || io.pending
	end push_back


    % Does the same as "puts", except appends a newline to "s".

    putl = proc (io: iodev, s: string)
	puts(io, s)
	puts(io, "\n")
	end putl


    % Does nothing if "io.page_size" is "invisible" or if a script file is
    % being read silently.  Otherwise, prints lines from "s" until the number
    % of lines permitted by "io.page_size" have been printed since the last
    % user input; then halts and prompts for user input.  As in the UNIX
    % program "more", the user may enter "<return>" to print the next line, a
    % digit "n" to print the next "n" lines, "<space>" to print the next
    % pageful, "d" to print the next half-pageful, and "q" to stop printing.
    % In addition, the user may enter "u" to suppress further "more" prompts
    % until the next request for user input.  These interactions are not
    % scripted or logged.

    puts = proc (io: cvt, s: string)
	if io.echoing < input_arr$size(io.input) then return end
	while true do
	    tagcase io.page_size
	       tag invisible: return
	       tag infinite:
		   stream$puts(io.output, s)
		   count_lines(io, s)
		   stream$puts(script$value_exists(io.log), s)
		      except when wrong_tag: end
		   return
	       tag num (size: int):
		   while ~string$empty(s) cand io.lines_on_page < size do
		       this_line, delim: string
		       this_line, delim, s := string_divide(s, "\n")
		       stream$puts(io.output, this_line)
		       stream$puts(io.output, delim)
		       count_lines(io, this_line)
		       count_lines(io, delim)
		       begin
			   str: stream := script$value_exists(io.log)
			   stream$puts(str, this_line)
			   stream$puts(str, delim)
			   end except when wrong_tag: end
		       end
		   if string$empty(s) then return end
		   io.page_size := new_size(io)
		   io.lines_on_page := 0
	       end
	    end
	end puts


    % (Internal procedure) Prompts the user for the size of the next page of
    % output.
    
    new_size = proc (io: rep) returns (page_size)
	help_string
	  = "---------------------------------------------------\n" ||
	    "<space>   display next screenful\n" ||
	    "<return>  display next line\n" ||
	    "<digit>   display next <digit> lines\n" ||
	    "d         display next half screenful\n" ||
	    "u         display continuously until next user interaction\n" ||
	    "q         display nothing until next user interaction\n"
	prompt_string = "-- More --"
	own erase_prompt: string := construct_erase_string(prompt_string)
	while true do
	    if io.column > 1 then stream$putl(io.output, "") end
	    stream$puts(io.output, prompt_string)
	    response: char := stream$getc_image(input_arr$bottom(io.input).source)
	    stream$display(stream$primary_output(), erase_prompt)
	    io.column := 1
	    if response = '?' then
	       stream$puts(io.output, help_string)
	     elseif response = '\n' then return(page_size$make_num(1))
	     elseif response = ' ' then return(io.default_page_size)
	     elseif response = 'd' then
	       ps: int := page_size$value_num(io.default_page_size)
	       return(page_size$make_num(ps/2))
	     elseif response = 'u' then return(page_size$make_infinite(nil))
	     elseif response = 'q' then return(page_size$make_invisible(nil))
	     else digit: int := string$indexc(response, "123456789")
		  if digit = 0 then
		     stream$puts(io.output, help_string)
		     else return(page_size$make_num(digit))
		     end
	     end
	    end
	end new_size


    % (Internal procedure) Returns a string that will cause "stream$display" to
    % erase "s", assuming that the cursor is positioned at the end of "s",
    % which is at the end of a line.  (Cf. ~CLU/stream.changes)

    construct_erase_string = proc (s: string) returns (string)
	erase: string := ""
	for c: char in string$chars(s) do erase := erase || "\020B" end
	return(erase || "\020L")
	end construct_erase_string


    % Outputs "n" spaces on "io".

    putspace = proc (io: iodev, n: int)
	puts(io, string_fill(' ', n))
	end putspace


    % Prints the strings in "strngs" in columns two characters wider than the
    % widest string in "strngs", indented "indent" spaces on each line.
    
    put_table = proc (io: iodev, strngs: string_arr, indent: int)
	if string_arr$empty(strngs) then return end
	width: int := 0
	for s: string in string_arr$elements(strngs) do
	    width := int$max(width, string$size(s))
	    end
	width := width + 2
	cols: int := int$max((io.line_length - indent - 1)/width, 1)
	rows: int := string_arr$size(strngs)/cols
	if rows*cols < string_arr$size(strngs) then rows := rows + 1 end
	for i: int in int$from_to(1, rows) do
	    putspace(io, indent)
	    for j: int in int$from_to(1, cols) do
	        s: string := strngs[i+rows*(j-1)]
		puts(io, s)
	        if j < cols then putspace(io, width - string$size(s)) end
		end except when bounds: end
	    putl(io, "")
	    end
	end put_table


    % Invokes "printl(io, s)" if there is no pending input on "io".

    qprintl = proc (io: iodev, s: string)
	if ~pending_input(io) then printl(io, s) end
	end qprintl

    
    % Invokes "prints(io, s)" if there is no pending input on "io".

    qprints = proc (io: iodev, s: string)
	if ~pending_input(io) then prints(io, s) end
	end qprints


    % Pushes "new_input" on top of the stack of input streams for "io", causing
    % subsequent read operations on "io" to get their input from "new_input".
    % If "silent" is true, suppresses output while "new_input" remains on the
    % stack.  The source of input reverts to its previous value (the primary
    % input, or another script file), and "new_input" is closed, when an
    % end-of-file is reached on "new_input", or "stop_reading_script(io, b)" is
    % called.  Signals "in_use_as_input" if "new_input" already appears on the
    % stack of input streams.  Signals "in_use_as_output" if it is currently
    % being used for logging or scripting.

    read_script = proc (io: cvt, new_input: stream, silent: bool) 
		    signals (in_use_as_input, in_use_as_output)
        valid_for_script(up(io), new_input)
	   resignal in_use_as_input, in_use_as_output
	input_arr$top(io.input).pending := io.pending
	io.pending := ""
	input_arr$addh(io.input, input_rec${source: new_input, pending: ""})
	int_arr$addh(io.command_id, 0)
	n: int := input_arr$size(io.input)
	if ~silent cand io.echoing = n - 1 then io.echoing := n end
	end read_script
    
    
    % Returns true iff "io" is presently taking its input from a script file,
    % that is, if one or more "read_script" operations have been performed on
    % "io" and the script streams have not yet been exhausted.

    reading_script = proc (io: cvt) returns (bool)
	return(input_arr$size(io.input) > 1)
	end reading_script


    % Stops logging for "io".  Signals "not_logging" if logging is not in
    % progress.

    rem_log = proc (io: cvt) signals (not_logging)
	tagcase io.log
	   tag exists (s: stream): stream$close(s)
				   io.log := script$make_none(nil)
	   tag none: signal not_logging
	   end
	end rem_log


    % Stops scripting of input from "io".  Signals "not_scripting" if input is
    % not being scripted.  Does not record the last command, which is presumed
    % to be that terminating the script, in the script.

    rem_script = proc (io: cvt) signals (not_scripting)
	tagcase io.script
	   tag exists (s: stream): stream$close(s)
				   io.script := script$make_none(nil)
	   tag none: signal not_scripting
	   end
	end rem_script


    % Resets indentation of the script, to take effect with the current
    % command (as opposed to "set_script_indent", which takes effect with the
    % next command).
    
    reset_script_indent = proc (io: cvt)
	io.script_indent := 0
	io.script_indent_prev := 0
	end reset_script_indent
    

    % Overrides a "quit" response to a "more" menu generated by "puts".
    % Typically used so that error messages will appear in the output.

    restart_output = proc (io: cvt)
	if page_size$is_invisible(io.page_size) then
	   io.page_size := io.default_page_size
	   io.lines_on_page := 0
	   end
	end restart_output


    % Sets the comment delimiter for "io" to "c".

    set_comment_char = proc (io: cvt, c: char)
	io.comment_char := c
	end set_comment_char
    
    
    % Sets the prompt used by "gets" for a new command.  The first exclamation
    % mark, if any, in the prompt is replaced by the number of the current
    % command when printed.
    
    set_command_prompt = proc (io: cvt, s: string)
	io.command_prompt := s
	end set_command_prompt
    
    
    % Sets "io.input_request", "io.null_response", and "io.handle_signal".

    set_communication = proc (io: cvt, input_request, null_response: string,
	    		      handle_signal: proctype ())
	io.input_request := input_request
	io.null_response := null_response
	io.handle_signal := handle_signal
	end set_communication
    

    % Resets "io.history" to "hist".
    
    set_history = proc (io: cvt, hist: command_arr)
	io.history := hist
	end set_history
    
    
    % Sets the number of commands remembered in the history of "io".

    set_history_setting = proc (io: cvt, n: int)
	io.history_size := n
	if n <= 0 then return end
	while command_arr$size(io.history) > n do
	    command_arr$reml(io.history)
	    end
	end set_history_setting


    % Sets the additional line break character for "io" to "c".

    set_line_break = proc (io: cvt, c: char)
	io.line_break := c
	end set_line_break


    % Sets paging mode on or off.  When on, output to "io" is suspended each
    % time the screen fills up between user interactions (supplying input to
    % the program itself and to the "more" prompt to continue output).

    set_page_mode = proc (io: cvt, on: bool)
	default_screen_size = 24
	if on
	   then if page_size$is_num(io.page_size) then return end
	   	% Previous line prevents output from executing a .lp file
		% from scrolling off screen when page mode is already on.
	   	lines: int := stream$get_page_length(io.output)
		   except when no_limit: lines := default_screen_size end
		io.default_page_size := page_size$make_num(lines-1)
		io.lines_on_page := 0
	   else io.default_page_size := page_size$make_infinite(nil)
	   end
        io.page_size := io.default_page_size
	end set_page_mode

    
    % Sets "io.script_indent" to "n".
    
    set_script_indent = proc (io: cvt, n: int)
	io.script_indent := int$max(n, 0)
	end set_script_indent
    
    
    % Sets "testing" to "b".
    
    set_testing_mode = proc (b: bool)
	testing := b
	end set_testing_mode
    

    % Returns "true" if an external signal has been received since the last
    % call of this procedure.  (Internal only?)

    signalled = proc () returns (bool)
	return(OS_check_sigusr1())
	end signalled


    % Signals "no_script" if input is not currently from a script stream.
    % Otherwise closes the script stream on top of the stack of input streams
    % for "io", and pops the stack, thereby causing further input from "io" to
    % be read from the primary input or an earlier script file.  Rings the bell
    % if input reverts to the primary input.
    
    % CLEANUP: This presumes that the only unnamed source stream is that
    % created from command line arguments.

    stop_reading_script = proc (io: cvt, abort: bool) signals (no_script)
	bell = "\007"
	if ~reading_script(up(io)) then signal no_script end
	msg: string
	if abort
	   then msg := "Aborting input from file `"
	   else msg := "End of input from file `"
	   end
        ir: input_rec := input_arr$remh(io.input)
	io.pending := input_arr$top(io.input).pending
	int_arr$remh(io.command_id)
	msg := msg || file_name$unparse(ir.source.name) || "'."
	   except when not_possible (*):
		       msg := msg || "command line arguments'." 
		  end
	stream$close(ir.source)
	if abort cor io.column > 1 then putl(up(io), "") end
	printl(up(io), msg || "\n")
	string_arr$addh(io.current_command_lines, comment_out(io, "", msg))
	if input_arr$size(io.input) = 1 then 
	   stream$display(io.output, bell)
	   end
	io.echoing := int$min(input_arr$size(io.input), io.echoing)
	end stop_reading_script


    % Strikes the last line from the script.
    
    % FIX: This does not work for "prove ... by ind; <>; []; []; []; qed"
    % It should not strike the whole line, but only one <> or [].
    
    strike_script = proc (io: cvt)
        string_arr$remh(io.current_command_lines)
	if string_arr$empty(io.current_command_lines) then
	   io.error_in_command := false
	   n: int := int_arr$size(io.command_id)
	   %	   io.command_id[n] := io.command_id[n] - 1
	   end
	end strike_script

    
    % Signals "in_use_as_input" if "new_input" already appears on the stack of
    % input streams.  Signals "in_use_as_output" if it is currently being used
    % for logging or scripting.

    valid_for_script = proc (io: cvt, new_input: stream)
			 signals (in_use_as_input, in_use_as_output)
 	if new_input.name = script$value_exists(io.script).name then
	   signal in_use_as_output
	   end except when wrong_tag, not_possible(*): end
 	if new_input.name = script$value_exists(io.log).name then
	   signal in_use_as_output
	   end except when wrong_tag, not_possible(*): end
 	if in_use(io, new_input) then signal in_use_as_input end
 	end valid_for_script


    % Writes "s" into the script as if it occurred as a (noncommand) line in
    % "io".
    
    write_script = proc (io: cvt, s: string)
	commit_command(up(io))
	string_arr$addh(io.current_command_lines, s)
	commit_command(up(io))
        end write_script


    % (Internal procedure) Adjusts, as a result of writing "s", the number of
    % lines written to "io.output" and the number of characters written on the
    % last line.

    count_lines = proc (io: rep, s: string)
	n: int := string$indexc('\n', s)
	while n > 0 do
	    io.total_lines := io.total_lines + 1
	    io.lines_on_page := io.lines_on_page + 1
	    io.column := 1
	    s := string$rest(s, n + 1)
	    n := string$indexc('\n', s)
	    end
	io.column := io.column + string$size(s)
	end count_lines


    % (Internal procedure.)  Invokes "io.handle_signal" if "signalled()" is
    % true.  Then gets a line of input from the topmost nonempty stream on the
    % "io.input" stack.  Signals "end_of_file" if all streams are empty.
    % Writes the line to the log file, if it exists.  Appends it to
    % "io.current_command_lines" if input is being scripted.
    
    % Outputs "io.input_request" prior to attempting to read the primary input.
    % Discards any line containing a non-empty "io.null_response" string read
    % from the primary input.  Discards any line beginning with two
    % "io.comment_char"s read from a script file.

    get_new_line = proc (io: rep) signals (end_of_file)
	need_line: bool := true
	% Try to get line from a script stream
	while need_line cand reading_script(up(io)) do
	    if signalled() then io.handle_signal() end
	    io.pending := stream$getl(input_arr$top(io.input).source)
	       except when end_of_file: stop_reading_script(up(io), false)
					continue
		      end
            io.total_lines := io.total_lines + 1
	    s: string := trim_head(io.pending)
	    if s[1] = io.comment_char cand s[1] = s[2] then continue end
	       except when bounds: end
	    need_line := false
	    end
	if need_line then % Try to get line from primary input
	   stream$puts(io.output, io.input_request)
	   stream$flush(io.output)
	   while true do
	       if signalled() then io.handle_signal() end
	       io.pending := stream$getl(input_arr$bottom(io.input).source)
		  resignal end_of_file
	       io.total_lines := io.total_lines + 1
	       io.column := 1
	       if io.null_response = ""
		    cor io.pending ~= io.null_response then break end
	       end
	   end 
        % ENHANCE: Trim leading whitespace if
	% string_arr$empty(io.current_command_lines); otherwise adjust
	% whitespace wrt command line
	io.pending := trim_tail(detab(io.pending))
	n: int := input_arr$size(io.input)
	if n <= io.echoing then
	   if 1 < n 
	      then putl(up(io), io.pending)
		   io.column := 1
	      else stream$putl(script$value_exists(io.log), io.pending)
	      end except when wrong_tag: end
	   end
	string_arr$addh(io.current_command_lines, io.pending)
	m: int := string$indexc(io.comment_char, io.pending)
	if m > 0 then io.pending := string$substr(io.pending, 1, m-1) end
	% CLEANUP: Fix "\n\n" hack, which makes line break character work.
	io.pending := 
	    string_replace_char(io.pending, io.line_break, "\n\n") || "\n"
	if ~reading_script(up(io)) then
	   io.page_size := io.default_page_size
	   io.lines_on_page := 0           % CLEANUP?
	   end
	end get_new_line


    % (Internal procedure) Indents the first line "lines" by "indent" and the
    % remaining lines relative to that.  ENHANCE: Make this procedure a
    % parameter to "commit_command" so that the indentation can be determined
    % by a client cluster.

    adjust_command_lines = proc (lines: string_arr, indent: int)
	com: string := lines[1]
	   except when bounds: return end
	% Indent the command line
	indent_str: string := ""
	if indent > 0 then indent_str := padr(" ", indent) end
	lines[1] := indent_str || trim_head(com)
	% Indents responses to queries following the command
        i: int := string_arr$size(lines)
	while i > 1 cand ~argument_end(lines[i]) do
	    lines[i] := indent_str || trim_head(lines[i])
	    i := i - 1
	    end
	% Indent arguments to the command
	indent := indent + 2
	while i > 1 do  
	    % Invariant: argument_end(io, lines[i])
	    lines[i] := padr(" ", indent) || trim_head(lines[i])
	    j: int := i - 1
	    spaces: int := 10000
	    while j > 1 cand ~argument_end(lines[j]) do
		spaces := int$min(spaces, string_prefix_size(lines[j], ' '))
		j := j - 1
		end
	    if indent < spaces then
	       for k: int in int$from_to(j+1, i-1) do
		   lines[k] := string$rest(lines[k], spaces - indent)
		   end
	     elseif indent > spaces then
	       offset: string := padr(" ", indent - spaces)
	       for k: int in int$from_to(j+1, i-1) do
		   lines[k] := offset || lines[k]
		   end
	     end
	    i := j
	    end
	end adjust_command_lines
    
    
    % (Internal procedure) A hack for now.
    
    argument_end = proc (s: string) returns (bool)
	m: int := string$indexc('%', s)
	if m > 0 then s := string$substr(s, 1, m-1) end
	return(trim_both(s) = "..")
	end argument_end

    
    % (Internal procedure)  Returns a string representation of "io.command_id".

    command_id = proc (io: rep) returns (string)
	s: string := ""
	for n: int in int_arr$elements(io.command_id) do
	    if ~string$empty(s) then s := s || "." end
	    s := s || int$unparse(n)
	    end
	return(s)
	end command_id
    
    
    % (Internal procedure) Inserts two copies of the comment delimiter followed
    % by "msg" before the first nonblank character in "s", unless "s" is
    % already commented out.
    
    comment_out = proc (io: rep, msg, s: string) returns (string)
	own prefix: string := string$c2s(io.comment_char) ||
		              string$c2s(io.comment_char) || " "
        for i: int in int$from_to(1, string$size(s)) do
	    if s[i] = ' ' cor s[i] = '\t' then continue end
	    if s[i] = io.comment_char cand s[i+1] = s[i] then break end
	    return(string$substr(s, 1, i-1) || prefix || msg || 
		   string$rest(s, i))
	    end except when bounds: end
	return(s)
	end comment_out

    
    end iodev
