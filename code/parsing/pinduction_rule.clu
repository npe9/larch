#extend

% This cluster parses and unparses external representations for induction rules
% using the following syntax:

%    induction-rule ::= "sort" sort "generated" [ "freely" ] "by" operator+,
%			  | "well founded" sort

% The "psort" cluster defines the nonterminal "sort".  The "poperator" cluster
% defines the nonterminal "operator".


pinduction_rule = cluster is print, read, read_rest

    rep = null
    
    
    % Prettyprints "ir" on "p".  Qualifies an "op" in "ir" if the current
    % "unparse_mode" is "qualified_mode" or if "op.id" is overloaded in
    % "symtab" and the current "unparse_mode" is "overloaded_mode" or
    % "unambiguous_mode".
    
    % ENHANCE: omit qualifications that can be inferred

    print = proc (p: printer, ir: induction_rule, stab: symtab)
	printer$start_block(p)
	p.indent := 2
	if induction_rule$is_wf(ir)
	   then printer$text(p, "well founded ")
	        operator$print(p, ir.relation, stab)
	   else	printer$text(p, "sort ")
	        sort$print(p, ir.sort)
		if induction_rule$is_free_structural(ir)
		    then printer$text(p, " generated freely by ")
		    else printer$text(p, " generated by ")
		    end
		printed: bool := false
		for op: operator in op_set$elements(ir.ops) do
		    if printed then printer$text(p, ", ") end
		    operator$print(p, op, stab)
		    printed := true
		    end
	   end
	printer$finish_block(p)
	end print
    

    % Reads and returns an induction rule from the head of "scan".  Writes a
    % message to "scan" if
    % (a) there is a syntax error,
    % (b) there is an undeclared operator,
    % (b) there is an ambiguous operator,
    % (c) an operator does not have the appropriate range sort,
    % (d) there are no basis operators, or
    % (e) an operator appears more than once.
    
    read = proc (scan: scanner, stab: symtab) returns (induction_rule)
	     signals (error)
	msg1 = "expecting a binary operator"
	msg2 = "expecting an operator with range `Bool'"
	msg3 = "expecting an operator with two equal domain sorts"
	if token$is_reserved_word(scan.nextToken, "well") 
	     cand token$is_reserved_word(scan.lookAhead, "founded") then
	   scanner$get(scan)
	   scanner$get(scan)
	   tok: token := scan.nextToken
	   if token$is_eof(tok) then
	      scanner$error(scan, "expecting an operator")
	      signal error
	      end
	   op: operator := operator$read(scan, stab)
	   if op.arity ~= 2 then
	      scanner$error_at(scan, tok.loc, msg1)
	      signal error
	    elseif op.rng ~= bool_sort() then
	      scanner$error_at(scan, tok.loc, msg2)
	      signal error
	    elseif op.dom[1] ~= op.dom[2] then
	      scanner$error_at(scan, tok.loc, msg3)
	      signal error
	    end
	   return(induction_rule$make_wf(op))
	   end resignal error
        begin
	    % ENHANCE: better message -- expecting "sort" or "well founded"
	    scanner$expecting_id(scan, "sort")
	    so: sort := sort$read(scan, stab)
	    return(read_rest(scan, stab, so))
	    end resignal error
	end read
    
    read_rest = proc (scan: scanner, stab: symtab, so: sort) 
		  returns (induction_rule) signals (error)
	msg = "operator not declared with generated sort as range"
	scanner$expecting_id(scan, "generated")
	    resignal error
	free: bool := false
	if token$is_reserved_word(scan.nextToken, "freely") then
	    scanner$get(scan)
	    free := true
	    end
	scanner$expecting_id(scan, "by")
	    resignal error
	if token$is_eof(scan.nextToken) then
	   scanner$error(scan, "expecting an operator")
	   signal error
	   end
	ops: op_set := op_set$[]
	basisOpExists: bool := false
	disambiguatedSomeOpByNeedForBasisOp: bool := false
	disambiguatedOpLoc: locator
	loc0: locator := scan.nextToken.loc
	while true do % Scan and disambiguate an operator
	    op: operator
	    oploc, op1loc: locator
	    opIsKnown: bool := false
	    opIsBasis: bool := false
	    disambiguatedThisOpByNeedForBasisOp: bool := false
	    yielded: bool := false
	    for op1: operator, loc1: locator 
		  in poperator$read_overloadings(scan, stab) do
		yielded := true
		op1loc := loc1
		if op1.rng ~= so then continue end
		op1IsBasis: bool := ~domain_contains_sort(op1, so)
		if opIsKnown
		   then if basisOpExists cor (op1IsBasis cand opIsBasis) then
			   exit bad(loc1, "ambiguous operator")
			   end
			disambiguatedThisOpByNeedForBasisOp := true
			if op1IsBasis then 
			   % Prefer basis "op1" to nonbasis "op"
			   op := op1
			   oploc := loc1
			   opIsBasis := true
			 elseif ~opIsBasis then
			   % Defer complaining about ambiguity until we see if
			   % we can disambiguate this operator as a basis op
			   opIsKnown := false
			   % else prefer basis "op" to nonbasis "op1"
			 end
		   else op := op1
		        oploc := loc1
		        opIsBasis := op1IsBasis
			opIsKnown := true
		   end
		end resignal error
	       except when none (loc1: locator): op1loc := loc1 end
	    if opIsKnown then
	       if disambiguatedThisOpByNeedForBasisOp then
		  disambiguatedSomeOpByNeedForBasisOp := true
		  disambiguatedOpLoc := oploc
		elseif opIsBasis cand disambiguatedSomeOpByNeedForBasisOp then
		  exit bad(disambiguatedOpLoc, "ambiguous operator")
		end
	       basisOpExists := basisOpExists cor opIsBasis
	     elseif yielded then exit bad(op1loc, msg)
	     else exit bad(op1loc, "undeclared operator")
	     end
	    op_set$insert(ops, op)
	       except when exists: exit bad(op1loc, "duplicate operator") end
	    if token$is_comma(scan.nextToken)
	       then scanner$get(scan)
	       else break
	       end
	    end except when bad (loc: locator, s: string):
			    scanner$error_at(scan, loc, s)
			    signal error
		       end
	return(induction_rule$make_structural(ops, free))
	   except when no_basis_ops: 
		       scanner$error_at(scan, loc0, "no basis generator")
		       signal error
		  end
	end read_rest
    
    
    % (Internal procedure) Returns "true" iff "so" is in the domain of "op".
    
    domain_contains_sort = proc (op: operator, so: sort) returns (bool)
	for so1: sort in sort_seq$elements(op.dom) do
	    if so = so1 then return(true) end
	    end
	return(false)
	end domain_contains_sort


    end pinduction_rule
