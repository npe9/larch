#extend

% This cluster parses and unparses external representations for facts, which
% can be formulas (i.e., equations or rewrite rules), deduction rules,
% induction rules, or operator theories.  Facts can also begin with ":<name>:",
% which specifies the name-prefix for the fact.

% See the "pformula", "pdeduction_rule", "pinduction_rule", and "pop_theory"
% clusters for syntactic details.

pfact = cluster is print, read
    
    rep = null
    
    
    % Prettyprints "f" on "p".
    
    print = proc (p: printer, f: fact, stab: symtab)
	tagcase f
	   tag dr (dr: deduction_rule): deduction_rule$print(p, dr, stab)
	   tag eq (eq: equation):       formula$print(p, eq, stab)
	   tag ir (ir: induction_rule): induction_rule$print(p, ir, stab)
	   tag ot (ot: op_theory):      op_theory$print(p, ot, stab)
	   tag rr (rr: rewrite_rule):   formula$print(p, rr, stab)
	   end
	end print
    

    % Reads and returns a fact from "scan".  Writes a message to "p" and
    % signals "error" if there are errors.
    
    read = proc (scan: scanner, stab: symtab) returns (fact) signals (error)
        msg = "expecting `generated by' or `partitioned by'"
        tok1: token := scan.nextToken
	named: bool := token$is_colon(tok1)
	n: name
	if named then
	   scanner$get(scan)
	   if ~token$is_nameId(scan.nextToken) then
	      scanner$error(scan, "expecting a name")
	      signal error
	      end
	   n := name$create(scanner$get(scan).text)
	   n1: name := stab.root_name
	   stab.root_name := n
	   n := symtab$new_name(stab)
	   stab.root_name := n1
	      except when not_possible:
			  scanner$error(scan, "illegal name prefix")
			  signal error
		     end
	   scanner$expecting(scan, token$is_colon, "a colon")
	   tok1 := scan.nextToken
	   end resignal error
       
	tok2: token := scan.lookAhead
	if token$is_reserved_word(tok1, "when") then
	   dr: deduction_rule := deduction_rule$read(scan, stab)
	   if named then dr.name := n end
	   return(fact$make_dr(dr))
	 elseif (token$is_reserved_word(tok1, "ac")
		   cor token$is_reserved_word(tok1, "commutative"))
		  cand (token$is_ifOp(tok2) 
		          cor token$is_markerSym(tok2)
		          cor token$is_openSym(tok2)
			  cor token$is_selectSym(tok2) 
			  cor token$is_simpleId(tok2)
			  cor token$is_somefixOp(tok2)) then
           ot: op_theory := op_theory$read(scan, stab)
	   if named then ot.name := n end
	   return(fact$make_ot(ot))
	 elseif token$is_reserved_word(tok1, "well")
		  cand token$is_reserved_word(tok2, "founded") then
	   ir: induction_rule := induction_rule$read(scan, stab)
	   if named then ir.name := n end
	   return(fact$make_ir(ir))
	 elseif token$is_reserved_word(tok1, "sort")
		  cand token$is_simpleId(tok2) then
	   scanner$get(scan)
	   s: sort := psort$read(scan, stab)
	   tok2 := scan.nextToken
	   if token$is_reserved_word(tok2, "generated") then
	      ir: induction_rule :=
		  pinduction_rule$read_rest(scan, stab, s)
	      if named then ir.name := n end
	      return(fact$make_ir(ir))
	    elseif token$is_reserved_word(tok2, "partitioned") then
	      dr: deduction_rule :=
		  pdeduction_rule$read_partitioned_rest(scan, stab, s)
	      if named then dr.name := n end
	      return(fact$make_dr(dr))
	    else scanner$error(scan, msg)
		 signal error
	    end
	 end resignal error
        fo: formula := formula$read(scan, stab)
	   resignal error
	if named then fo.name := n end
	return(fact$make_eq(fo))
	end read

    
    end pfact
