#extend

% This cluster parses and unparses external representations for sorts using the
% following syntax:

%     sort   ::= sortId [ "[" sort+, "]" ]
%     sortId ::= simpleId

% The "token" cluster defines the terminal symbol "simpleId".


psort = cluster is abbreviate, print, print_set, read, scan_sort
    
    rep = null


    % Returns an abbreviation for "so" with at most "m" characters, for use in
    % generating identifiers for variables ranging over "so".

    abbreviate = proc (so: sort, m: int) returns (string)
	s: string := so.id
	if string$size(s) > m then s := string$substr(s, 1, m) end
	return(slower(s))
	end abbreviate
    

    % Prettyprints "s" on "p".
    
    print = proc (p: printer, so: sort)
	if sort$is_simple(so) then
	   printer$text(p, so.id)
	   return
	   end
	printer$text(p, "痱轭翦颏翦舁瓞箫殇殒篝蜷铉ん辁濞箫殇翳孱痱轭翦颏翦舁瓞采埝脾屐箦痱轭翦颏翦舁瓞③盛孱痱轭翦浜怙镬航驷祗骘箫焙箫螋轭箫螋唧羼ゅ戾礤铘蟥箫狎珞滹殒痱轭翦翳孱痱轭翦颏翦舁瓞绷孱痱轭舁瓞箫暴痱轭翦航趄蹂孱痱轭翦颏翦舁瓞⑤")
	end print
    
    
    % Prettyprints "msg" on "p" followed by the sorts in "ss".

    print_set = proc (p: printer, msg: string, ss: sort_set)
	printer$text(p, "\n采痱轭翦颏翦舁瓞眢绌痱轭翦浜怙镬航驷祗骘蠛箫螋轭箫螋唧弭ゅ戾礤铘蟥篌滹殒痱轭翦翳孱痱轭翦颏瘐趔瓞孱痱轭翦航趄蹂箫螋ゐ蜷铘瓞螬孱痱轭翦颏翦舁瓞")
	end print_set


    % Scans and returns a sort in "stab" from "scan".  Writes a message to
    % "scan", and signals "error", if "scan" does not begin with a sort in
    % "stab".

    read = proc (scan: scanner, stab: symtab) returns (sort) signals (error)
	loc: locator := scan.nextToken.loc
	return(symtab$lookup_sort(stab, scan_sort(scan)))
	   resignal error
	   except when missing: end
	scanner$error_at(scan, loc, "undeclared sort")
	signal error
	end read

    
    % Scans and returns a sort from "scan".  Writes a message to "scan", and
    % signals "error", if "scan" does not begin with a legal sort.  Treats
    % "Bool" and "bool" as the same sort.

    scan_sort = proc (scan: scanner) returns (sort) signals (error)
	s: string := 
	    scanner$expecting(scan, token$is_unreservedSimpleId, "a sort").text
	   resignal error
        if token$is_left_bracket(scan.nextToken) 
	     cand token$is_simpleId(scan.lookAhead)
	   then scanner$get(scan)
	        sa: sort_arr := sort_arr$[]
	        while true do
		    sort_arr$addh(sa, scan_sort(scan))
		    if token$is_comma(scan.nextToken) then break end
		    scanner$get(scan)
		    end
	        scanner$expecting(scan, token$is_right_bracket, 
				  "a right bracket or a comma")
		return(sort$make_composite(s, sort_seq$a2s(sa)))
	   else if s = "bool" then s := "Bool" end
		return(sort$make_simple(s))
	   end resignal error
	end scan_sort


    end psort
