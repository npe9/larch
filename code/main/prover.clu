#extend

% A "prover" manages forward and backward inferences.  Forward inferences are
% performed by "prover$make_inferences", which deduces consequences from facts
% in a "system".  Backward inferences create and establish conjectures, often
% by creating and establishing other conjectures as subgoals.

% A "prover" maintains a forest of unproved conjectures, introduced either by
% the user via the "prove" command or by LP in response to user-chosen methods
% of proof for other conjectures.  The root nodes in the forest are known as
% "theorem" nodes.  The other nodes are known as "lemma" or "subgoal" nodes,
% and are used as follows.

% Conjectures introduced by the user occur in either theorem or lemma nodes.  A
% theorem node contains a conjecture introduced in a context in which no other
% proofs are in progress.  A lemma node contains a conjecture introduced during
% the proof of the conjecture in its parent node.

% Conjectures introduced by LP occur in subgoal nodes.  If a node has subgoal
% nodes, its proof is complete once the conjectures in them have all been
% established.

% The conjectures in theorem and lemma nodes can be formulas, deduction rules,
% induction rules, or (nonfree) operator theories.  LP automatically generates
% subgoals that are formulas for all conjectures, so that the conjectures in
% subgoal nodes are always formulas.

% Associated with each node in the proof forest is the following information:
% (a) the conjecture at that node;
% (b) a method of proof;
% (c) additional hypotheses that can be used to prove a conjecture that is a
%     subgoal (the hypotheses are determined by the parent's method of proof);
% (d) the state of the symbol table and the system at the node (initially
%     accompanied by information telling how to initialize the state);
% (e) the current normalization for a conjecture that is a formula;
% (f) information about how the conjecture in a theorem or lemma node is to be 
%     used once it is established (i.e., its activity and immunity).
% In the experimental version, nodes do not keep track of the state of the
% system, as described in (d).

% For now, LP uses a stack to constrain the traversal order for the proof
% forest.  In the experimental version, LP pushes and pops the state of the
% system as it traverses the forest; in the nonexperimental version, LP copies
% and restores the system.  Work on subgoals and lemmas must be finished before
% work resumes on their parents.  Work is always done on the "current"
% conjecture, which is on top of the stack.  There is only one theorem node,
% which is at the bottom of the stack and contains the oldest unproved
% conjecture.  Except for the current conjecture, nodes in the forest have one
% or more children, which are immediately above them in the stack.  If a node
% has more than one child, then all its children are subgoal nodes.

% To prove a formula "f" by cases "f1, ..., fn", LP creates "n+1" subgoals.  If
% "n > 1", the first subgoal involves proving "f1 \/ ... \/ fn".  If "n = 1",
% LP supplies a default second case of "~f1".  For each case "i", there is a
% subgoal that involves proving "f'" from the system supplemented by the case
% hypothesis "fi'" (possibly by deriving an inconsistency from the enlarged
% system), where "f'" and "fi'" are obtained by substituting new constants for
% the variables of "fi" in both "f" and "fi".

% To prove a formula "f" by contradiction, LP creates a subgoal that involves
% deriving an inconsistency from the system supplemented by the hypothesis
% "~f'", which is obtained by substituting new constants for the variables in
% "~f".
    
% To prove a formula "f" by induction on a variable "v" using induction rule
% "ir", LP establishes subgoals for the basis and induction steps as described
% in the "induction_rule" cluster.

% To prove a deduction rule 
%      when h1, ..., hm yield c1, ..., cn
% LP creates a subgoal for each "i" from 1 to "n" that involves proving "ci'"
% from the hypotheses "h1'", ...,"hm'" where "h1'", ..., "hm'" and "ci'" are
% obtained by substituting new constants for all free variables in "h1", ...,
% "hm", both in "h1", ..., "hm" and in "ci".

% To prove an induction rule "S generated by f1, ..., fn", LP creates a single
% subgoal that involves proving "isGenerated(x)", where "isGenerated" is a
% new function symbol, from "n" hypotheses formed as follows:
%   isGenerated(f)		                    % when f:->S
%   isGenerated(x) => isGenerated(f(x))             % when f:S->S
%   isGenerated(f(y1, ..., yk))                     % when f:S1,...,Sk->S,
%   (isGenerated(x1) /\ ... /\ isGenerated(xm))     % when f:S,...,S1,...,Sk->S
%      => isGenerated(f(x1, ..., xm, y1, ..., yk))
% (Here "S1", ..., "Sk" are sorts other than "S"; "x", "x1", ..., "xm" are
% variables of sort "S"; and "y1", ..., "yk" are variables of sort "S1", ...,
% "Sk".  Suitable variants of the last hypothesis are used for other
% permutations of the domain sorts of a generator "f".)

% To prove an induction rule "well founded <", LP creates a single subgoal that
% involves proving "isGenerated(x)", where "isGenerated" is a new function
% symbol, from the hypothesis
%   \A y (y < x => isGenerated(y)) => isGenerated(x)
% (Here "x" and "y" are variables of sort "S", where "<" has signature 
% "S,S->Bool".)
    

prover = cluster is
	create,			% returns new prover
	add_conjecture,		% creates a new conjecture
	attempt_proofs,		% tries to prove conjectures
	apply_drs,		% continues proof by explicit deduction
	cancel_all,		% cancels all proofs in progress
	cancel_lemma,		% cancels current lemma or theorem
	cancel_proof,		% cancels current conjecture
	change_activity,	% changes activity of named conjectures
	change_immunity,	% changes immunity of named conjectures
	current_only,		% returns prover for freezing current context
	display,		% displays named conjectures
	display_stack,		% displays proof stack
	get_box_checking,	% returns true if box-checking is on
	get_conjecture,		% returns the current conjecture
	get_current,		% dummy, for consistency with xprover.clu
	get_default_methods,	% returns list of default proof methods
	get_ops,		% returns operator set for current conjecture
	make_inferences,	% performs forward inferences
	qed,			% checks that all conjectures have been proved
	reduce_conjecture,	% continues proof by explicit reduction
	reflatten,		% reflattens conjecture
	reset_method,		% sets proof method
	set_box_checking,	% sets box-checking mode
	set_default_methods,	% sets list of default proof methods
	set_indentation,	% sets indentation for script file
	valid_method,		% returns true if proof method can be used
	zap,			% tries to finish proof by decision procedures
	_gcd			% necessary for gc_dump


    rep = record[box_error: bool,	   % indicates missing box
    		 new_conjecture: bool,	   % indicates change to stack
    		 outer_methods: npm_seq,   % default methods before proofs
    		 outer_symtab: symtab,	   % symtab before proofs
		 outer_system: system,	   % system before proofs
    		 stack: conj_arr]	   % conjecture stack
    		 
    conj_arr = array[conjecture]
    conjecture = record[ai: ai_settings,	   % take effect when proved
    			conj: fact,		   % original conjecture
			default_methods: npm_seq,  % default proof methods
			hyps: fo_arr,		   % hypotheses for conjecture
			inits: init_arr,	   % initialization for state
			kind: node_kind,	   % theorem, lemma, or subgoal
			method: proof_method,	   % method of proof
    			normalized: formula,	   % normalized conjecture
			pops: int,		   % finalization for system
			printed: int,		   % when last printed
			proved: bool,		   % true if proved
			symtab: symtab,		   % symtab to use
			sys: system]		   % system to use

    init_arr = array[init]			   % proof initializations
    init = oneof[copy, diamond, hyps, push: null]
    add_hyps = init$make_hyps(nil)		   % add hypotheses
    copy_state = init$make_copy(nil)		   % copy symbol table, system
    push_system = init$make_push(nil)		   % push system an extra time

    % NOTE: In the experimental version, "copy_symtab" would be a better
    % name for "copy_state ".
    
    node_kind = oneof[lemma: int,	 	   % for pr.stack[int]
    		      subgoal: subgoal_info,
    		      theorem: null]		   % top level conjecture
		      
    subgoal_info = struct[goal: int,		   % which subgoal
    			  parent: int]		   % for pr.stack[int]
    
    box_indent = 2     

    to_show = oneof[always, never, old: null] 	   % for showing conjectures
    show_always = to_show$make_always(nil)
    show_never  = to_show$make_never(nil)
    show_old    = to_show$make_old(nil)

    % ENHANCE: Add "subgoals: conj_arr" to the rep for "conjecture".  Then
    % "display proof-status" can show what progress has been made on a
    % conjecture (by running through the subgoals and seeing which ones have
    % been proved).  This costs some space, because we will keep extra copies
    % of the system around longer.


    own truth: term 		:= term0(op_true())
    own falsity: term 		:= term0(op_false())
    own inconsistency: formula  := make_inconsistency()
    own dummy_op_sys: op_system := op_system$[]
    own dummy_symtab: symtab 	:= symtab$blank()
    
    % Global settings

    own box_checking: bool       := setting$value_b(default_box_checking)

			      
    % Returns a new "prover" with no conjectures.

    create = proc (a: args) returns (cvt)
	args = struct[symtab: symtab, system: system]
	return(rep${box_error: false, 
	            new_conjecture: false, 
	            outer_methods: initial_proof_methods,
		    outer_symtab: a.symtab, 
		    outer_system: a.system, 
		    stack: conj_arr$[]})
	end create


    % Stacks a new conjecture that involves proving "f".  Names "f" and
    % classifies it as a lemma for the current conjecture, or as a theorem if
    % there is no current conjecture.  Signals "implied_ir" if "f" is an
    % induction rule that is subsumed by some other induction rule in "i.sys".

    add_conjecture = proc (i: interactive, f: fact) signals (implied_ir)
	statistics$start_prover()
	if system$implies_ir(i.sys, fact$value_ir(f)) then
	   statistics$stop_prover()
	   signal implied_ir
	   end except when wrong_tag: end
	remember_progress(i)
	pr: rep := down(i.prover)
	size: int := conj_arr$size(pr.stack)
	k: node_kind
	if size = 0
	   then k := node_kind$make_theorem(nil)
	   else k := node_kind$make_lemma(size)
	   end
        ai: ai_settings
	tagcase f
	   tag dr: ai := i.sys.default_ai
	   tag eq: ai := i.sys.default_ai
	   others: ai := ai_settings${active: true, immune: immunity_off}
	   end
	if ai.immune = immunity_anc then ai.immune := immunity_off end
	if ~fact_named(f) then
	   set_fact_name(f, symtab$new_name(i.symtab))
	   end
        norm: formula := fact$value_eq(f)
	   except when wrong_tag: norm := inconsistency end
	sys1: system
	inits: init_arr
	if interactive$get_experimental()
	   then sys1 := i.sys
	        inits := init_arr$[copy_state]
	   else sys1 := system$copy(i.sys)
	        inits := init_arr$[]
	   end
        c: conjecture := conjecture${ai: ai,
				     conj: f,
				     default_methods: up(pr).default_methods,
				     hyps: fo_arr$[],
				     inits: inits,
				     kind: k,
				     method: proof_method$make_default(nil),
				     normalized: norm,
				     pops: 0, 		% Experimental
				     printed: 0,
				     proved: false,
				     symtab: symtab$copy_ids(i.symtab),
				     sys: sys1}
	conj_arr$addh(pr.stack, c)
	pr.new_conjecture := true
	statistics$stop_prover()
	end add_conjecture
    
    
    % Attempts to prove the current conjecture by using one of the deduction
    % rules named by "ns".  Continues proof attempts if the attempt was
    % successful.

    apply_drs = proc (i: interactive, ns: name_set) signals (error(string))
	pr: rep := down(i.prover)
	conj: conjecture := conj_arr$top(pr.stack)
	   except when bounds: signal error("There are no conjectures.") end
	if ~fact$is_eq(conj.conj) then
	   signal error("The current conjecture is not a formula.")
	   end
        remember_progress(i)
	if system$deduce_formula_from(conj.normalized, i.sys, i.symtab, ns)
	   then report_proof(i, "by explicit deduction")
	        attempt_proofs(i)
	   else printer$text(i.p, "\n~{The conjecture was not proved.~}\n")
	   end
	end apply_drs
    
    
    % Proves conjectures, starting with the current conjecture and popping
    % conjectures off the stack as they are proved.  Returns when a proof gets
    % stuck, box or diamond checking fails, or the user requests an interrupt.

    attempt_proofs = proc (i: interactive)
	statistics$start_prover()
	remember_progress(i)
	set_goals(i)
	   except when diamond_error: statistics$stop_prover()
				      return
		  end
	% If we get here, either all conjectures have been proved or we are
	% attempting to prove a formula by normalization or explicit commands.
 	% Any new hypotheses or recently proved facts are in "i.sys", but may
 	% not have been used to reduce the conjecture or to internormalize
 	% "i.sys".
	make_inferences(i, stabilize_task_mode)
	   except when interrupt, proved: end
	pr: rep := down(i.prover)
	statistics$stop_prover()
	c: conjecture := conj_arr$top(pr.stack)
	   except when bounds: return end
	printer$newline(i.p)
	describe_conjecture(pr, i.p, c, "Suspending proof of ", show_old, 
	                    show_old)
	end attempt_proofs


    % Cancels the proofs of all conjectures.
    
    cancel_all = proc (i: interactive) signals (none)
	pr: rep := down(i.prover)
	if conj_arr$empty(pr.stack) then signal none end
	statistics$start_prover()
	if interactive$get_experimental() 
	   then while true do
		    pop_system(i.sys, conj_arr$remh(pr.stack))
		    end except when bounds: end
	   else pr.stack := conj_arr$[]
	   end
	select_context(i)
	printer$text(i.p, "\n~{All proofs have been canceled.~}\n")
	statistics$stop_prover()
	end cancel_all


    % Cancels the current lemma and all of its subgoals.

    cancel_lemma = proc (i: interactive) signals (none)
	pr: rep := down(i.prover)
	conj: conjecture := conj_arr$remh(pr.stack)
	   except when bounds: signal none end
	statistics$start_prover()
	if interactive$get_experimental() then pop_system(i.sys, conj) end
	while node_kind$is_subgoal(conj.kind) do 
	    conj := conj_arr$remh(pr.stack)
	    if interactive$get_experimental() then pop_system(i.sys, conj) end
	    end
	pr.new_conjecture := true
	printer$newline(i.p)
	describe_conjecture(pr, i.p, conj, "Deleted ", show_old, show_never)
	printer$newline(i.p)
	select_context(i)
	statistics$stop_prover()
	end cancel_lemma


    % Cancels the current conjecture.  If the current conjecture is a subgoal,
    % pops the proof stack back to the parent of the subgoal and sets its proof
    % method to "default".

    cancel_proof = proc (i: interactive) signals (none)
	pr: rep := down(i.prover)
	conj: conjecture := conj_arr$top(pr.stack)
	   except when bounds: signal none end
	statistics$start_prover()
	new_top: int 
	msg: string
	tagcase conj.kind
	   tag theorem, lemma:
	       msg := "Deleted "
	       new_top := conj_arr$size(pr.stack) - 1
	   tag subgoal (si: subgoal_info):
	       msg := "Proof method has been reset for "
	       new_top := si.parent
	       conj := pr.stack[si.parent]
	       conj.method := proof_method$make_default(nil)
	   end
	printer$newline(i.p)
        describe_conjecture(pr, i.p, conj, msg, show_old, show_never)
	printer$newline(i.p)
	while conj_arr$size(pr.stack) > new_top do
	    if interactive$get_experimental()
	       then pop_system(i.sys, conj_arr$remh(pr.stack))
	       else conj_arr$remh(pr.stack)
	       end
	    end
	pr.new_conjecture := true
	select_context(i)
	statistics$stop_prover()
	end cancel_proof


    % Sets the activity of all nonsubgoal conjectures named by "ns" to
    % "active".  The setting takes effect when the conjecture is proved.
    
    change_activity = proc (pr: cvt, ns: name_set, active: bool)
	for conj: conjecture in conj_arr$elements(pr.stack) do
	    if conj.ai.active ~= active cand node_kind$is_theorem(conj.kind)
		 cand ~fact$is_ot(conj.conj) cand ~fact$is_ir(conj.conj)
		 cand name_set$contains_fact(ns, conj.conj) then
	       conj.ai.active := active
	       end
	    end
	end change_activity


    % Sets the immunity of all nonsubgoal conjectures named by "ns" to "immune"
    % (or to "immunity_off" if "immune" is "immunity_anc", because theorems do
    % not have ancestors).  The setting takes effect when the conjecture is
    % proved.
    
    change_immunity = proc (pr: cvt, ns: name_set, immune: immunity)
	for conj: conjecture in conj_arr$elements(pr.stack) do
	    if conj.ai.immune ~= immune cand node_kind$is_theorem(conj.kind)
		 cand ~fact$is_ot(conj.conj) cand ~fact$is_ir(conj.conj)
		 cand name_set$contains_fact(ns, conj.conj) then
	       if immune = immunity_anc
		  then conj.ai.immune := immunity_off
		  else conj.ai.immune := immune
		  end
	       end
	    end
	end change_immunity

    
    % Returns a prover suitable for freezing only the current conjecture.

    current_only = proc (pr: cvt) returns (cvt)
	conj: conjecture := conj_arr$top(pr.stack)
	   except when bounds: return(pr) end
	pr := rep$copy1(pr)
	pr.stack := conj_arr$[]
	conj := conjecture$copy1(conj)
	conj.kind := node_kind$make_theorem(nil)
	conj.pops := 0
	conj_arr$addh(pr.stack, conj)
	pr.outer_symtab := conj.symtab
	pr.outer_system := conj.sys
	return(pr)
	end current_only
    

    % Displays the names and status of all conjectures on the path to the
    % current conjecture.

    display_stack = proc (p: printer, pr: cvt) signals (interrupt)
	c: conjecture := conj_arr$top(pr.stack)
	   except when bounds:
		       printer$text(p, "\nNo conjectures.\n\n")
		       return
		  end
	n: int := conj_arr$high(pr.stack)
	path: conj_arr := conj_arr$[c]
	while true do
	    tagcase c.kind
	       tag lemma: n := n - 1
	       tag subgoal (si: subgoal_info): n := si.parent
	       tag theorem: break
	       end
	    c := pr.stack[n]
	    conj_arr$addl(path, c)
	    end
	printer$newline(p)
	for conj: conjecture in conj_arr$elements(path) do
	    if front_end$interrupt() then signal interrupt end
	    describe_conjecture(pr, p, conj, "", show_always, show_always)
	    if ~fo_arr$empty(conj.hyps) then
	       printer$text(p, "~{  ~IHypotheses for subgoal:~1A")
	       h_printed: bool := false
	       for h: formula in fo_arr$elements(conj.hyps) do
		   if h_printed then printer$text(p, ",~1A") end
		   name$print(p, h.name)
		   h_printed := true
		   end
	       printer$text(p, "~}\n")
	       end
	    printer$text(p, "~{  ~I")
	    if proof_method$is_default(conj.method)
	       then printer$text(p, "Proof not yet begun")
	       else printer$text(p, "Attempting a proof ")
		    print_method(p, conj, "of ")
		    printer$text(p, "~2I")
		    print_cases(p, conj)
		    % ENHANCE: show subgoals, if any
	       end
	    printer$text(p, "~}\n")
	    end
	printer$text(p, "\n")
	end display_stack


    % If "ns" is the universal name set (i.e., no names were specified with the
    % "display" command"), displays the current conjecture.  Otherwise displays
    % all conjectures with names in "ns".  ENHANCE: If a formula is used as a
    % subgoal more than once, display it just once.

    display = proc (p: printer, pr: cvt, ns: name_set) signals (interrupt)
	disp: conj_arr := conj_arr$[]
	if name_set$is_universal(ns)
	   then conj_arr$addh(disp, conj_arr$top(pr.stack))
	   else	for conj: conjecture in conj_arr$elements(pr.stack) do
		    if name_set$contains_fact(ns, conj.conj) then
		       conj_arr$addh(disp, conj)
		       end
		    end 
	   end except when bounds: end
	if conj_arr$empty(disp) then
	   printer$text(p, "\nNo conjectures.\n\n")
	   return
	   end
        printer$text(p, "~{")
	for conj: conjecture in conj_arr$elements(disp) do
	    if front_end$interrupt() then signal interrupt end
	    n: int := 0
	    conj1: conjecture := conj
	    while true do
		tagcase conj1.kind
		   tag lemma (c: int):             conj1 := pr.stack[c]
		   tag subgoal (si: subgoal_info): conj1 := pr.stack[si.parent]
		   tag theorem: break
		   end
		n := n + box_indent
		end
	    p.indent := n
	    printer$text(p, "\n~{")
	    describe_conjecture(pr, p, conj, "", show_always, show_always)
	    printer$text(p, "~0I~}")
	    end
	printer$text(p, "~}\n")
	end display


    % Returns "true" if box checking is in effect.
    
    get_box_checking = proc () returns (bool)
	return(box_checking)
	end get_box_checking
    
    
    % Returns the current conjecture.  Signals "none" if there are no proofs
    % in progress.

    get_conjecture = proc (pr: cvt) returns (fact) signals (none)
	c: conjecture := conj_arr$top(pr.stack)
	   except when bounds: signal none end
	if fact$is_eq(c.conj)
	   then return(fact$make_eq(c.normalized))
	   else return(c.conj)
	   end
	end get_conjecture


    % Dummy procedure, for consistency with xprover.clu
    
    get_current = proc (pr: cvt)
	fail("prover$get_current: not implemented")
	end get_current
    

    % Returns the list of default proof methods for conjectures that are
    % formulas.
    
    get_default_methods = proc (pr: cvt) returns (npm_seq)
	return(conj_arr$top(pr.stack).default_methods)
	   except when bounds: end
	return(pr.outer_methods)
	end get_default_methods


    % Returns the set of operators in the current conjecture.
    
    get_ops = proc (pr: cvt) returns (op_set)
	tagcase conj_arr$top(pr.stack).conj
	   tag dr (dr: deduction_rule): return(dr.ops)
	   tag eq (fo: formula): return(fo.ops)
	   tag ir (ir: induction_rule): return(ir.ops)
	   tag ot (ot: op_theory): return(ot.ops)
	   tag rr (rr: rewrite_rule): return(rr.ops)
	   end except when bounds: return(op_set$[]) end
	end get_ops
    
    
    % Performs forward inferences according to "m".  If a conjecture is
    % established (because a formula reduces to an identity or an inconsistent
    % hypothesis is detected), reports the successful proof and initiates work
    % on the next conjecture.  Signals "proved" if one or more conjectures are
    % proved or if a top-level inconsistency is detected.  Signals "interrupt"
    % if some equation could not be ordered into a rewrite rule, if the user
    % types ^G, if the user suspends the interactive ordering procedure, or if
    % a box or diamond error is detected.
    
    make_inferences = proc (i: interactive, m: named_task_mode)
			signals (interrupt, proved)
        statistics$start_prover()
	pr: rep := down(i.prover)
        proved: bool := false
        while true do
	    goal_exists: bool := true
	    c: conjecture := conj_arr$top(pr.stack)
	       except when bounds: goal_exists := false end
	    if goal_exists 
		 cand (c.proved cor
		       fact$is_eq(c.conj) cand formula$is_identity(c.normalized))
	       then proved := true
	            report_proof(i, "")
		    set_goals(i)
		    m := stabilize_task_mode
		    continue
	       end
	    if goal_exists cand proof_method$is_normal(c.method) cand ~c.proved
	       then i.sys.goal := goal$make_exists(c.normalized)
	       else i.sys.goal := goal$make_none(nil)
	       end
	    if pr.box_error then
	       pr.box_error := false
	       statistics$stop_prover()
	       signal interrupt
	       end
	    interrupt: bool := false
	    ordered: bool := true
	    begin
		system$do_tasks(i.sys, m, i.p, i.symtab)
		end except when inconsistent (fo: formula):
				proved := true
				handle_inconsistency(i, fo)
				set_goals(i)
				m := stabilize_task_mode
				continue
			   when interrupt:
				iodev$restart_output(i.io)
				printer$error(i.p)
				printer$text(i.p, "\nInterrupt...\n")
				interrupt := true
			   when proved:
				proved := true
				report_proof(i, "")
				set_goals(i)
				m := stabilize_task_mode
				continue
			   when suspend:
				printer$text(i.p, "\nOrdering suspended...\n")
				interrupt := true
			   when unorderable:
				printer$text(i.p, "\nThe formulas cannot be ")
				printer$text(i.p, "ordered using the current ")
				printer$text(i.p, "ordering.\n")
				ordered := false
			   end
	    c.normalized := goal$value_exists(i.sys.goal)
	       except when wrong_tag: end
	    if interrupt then 
	       statistics$stop_prover()
	       signal interrupt
	       end
	    if ordered cand m = order_task_mode then
	       neqs, nrrs, ndrs: int := system$size(i.sys)
	       if neqs = 0
		  then printer$text(i.p, "\nAll equations ")
		  else printer$text(i.p, "\nThe named equations ")
		  end
	       printer$text(i.p, "have been oriented into rewrite rules.  ")
	       printer$text(i.p, "The rewriting system is ")
	       if ~i.sys.terminates then printer$text(i.p, "NOT ") end
	       printer$text(i.p, "guaranteed to terminate.\n")
	       end
	    if goal_exists cand proof_method$is_normal(c.method) then
	       if is_valid(c.conj, c.normalized, implies_proof_method.pm)
		    cand in_seq[named_proof_method]
			     (implies_proof_method, c.default_methods) then
		  c.method := implies_proof_method.pm
		  m := stabilize_task_mode
		  start_implies_proof(i)
		  set_goals(i)
		  continue
		elseif is_valid(c.conj, c.normalized, and_proof_method.pm)
			 cand in_seq[named_proof_method]
				  (and_proof_method, c.default_methods) then
		  c.method := and_proof_method.pm
		  m := stabilize_task_mode
		  start_and_proof(i)
		  set_goals(i)
		  continue
		elseif is_valid(c.conj, c.normalized, if_proof_method.pm)
			 cand in_seq[named_proof_method]
				  (if_proof_method, c.default_methods) then
		  c.method := if_proof_method.pm
		  m := stabilize_task_mode
		  start_if_proof(i)
		  set_goals(i)
		  continue
		elseif is_valid(c.conj, c.normalized, iff_proof_method.pm)
			 cand in_seq[named_proof_method]
				  (iff_proof_method, c.default_methods) then
		  c.method := iff_proof_method.pm
		  m := stabilize_task_mode
		  start_iff_proof(i)
		  set_goals(i)
		  continue
		end
	       end
	    break      % No further progess can be made
	    end except when diamond_error: 
			    statistics$stop_prover()
			    signal interrupt
		       end
	statistics$stop_prover()
	if proved then signal proved end
	end make_inferences


    % Checks that all conjectures have been proved.  Prints an error message if
    % this is not the case.

    qed = proc (i: interactive) signals (error)
	pr: rep := down(i.prover)
	if conj_arr$empty(pr.stack)
	   then printer$text(i.p, "\n~{All conjectures have been proved.~}\n")
	   else printer$error(i.p)
	        printer$newline(i.p)
	        describe_conjecture(pr, i.p, conj_arr$top(pr.stack), 
		                    "Still attempting to prove ", 
				    show_old, show_never)
	        printer$newline(i.p)
		signal error
	   end
	end qed


    % Reduces (if "normalize" is false) or normalizes (if "normalize" is true)
    % the current conjecture by the rewrite rules named by "ns".  Continues
    % proof attempts if the reduction was successful.

    reduce_conjecture = proc (i: interactive, normalize, reverse: bool, 
	                      ns: name_set) signals (error(string))
	pr: rep := down(i.prover)
	conj: conjecture := conj_arr$top(pr.stack)
	   except when bounds: signal error("There are no conjectures.") end
	if ~fact$is_eq(conj.conj) then
	   signal error("The current conjecture is not a formula.")
	   end
        remember_progress(i)
	fo: formula
	if normalize
	   then fo := system$normalize_formula_by(conj.normalized, i.sys, 
						  i.symtab, ns, reverse)
	   else fo := system$reduce_formula_by(conj.normalized, i.sys, 
					       i.symtab, ns, reverse)
	   end
	   except when already_normal_form:
		       printer$text(i.p, 
			            "\n~{The conjecture was not reduced.~}\n")
		       return
		  when might_loop (fo1: formula):
		       fo := fo1
		  end
	conj.normalized := fo
	attempt_proofs(i)
	end reduce_conjecture
    
    
    % Reflattens the current conjecture.  Invoked when an operator theory is
    % added to or deleted from the system.  Conjectures other than the current
    % conjecture are not reflattened because the addition or deletion affects
    % only the system for the current conjecture.
    
    reflatten = proc (i: interactive)
	remember_progress(i)
	pr: rep := down(i.prover)
	conj: conjecture := conj_arr$top(pr.stack)
	   except when bounds: return end
	conj.conj := system$flatten_fact(conj.conj, i.sys)
	if fact$is_eq(conj.conj) then 
	   conj.normalized := system$flatten_eq(conj.normalized, i.sys)
	   end
	for n: int in fo_arr$indexes(conj.hyps) do
	    conj.hyps[n] := system$flatten_eq(conj.hyps[n], i.sys)
	    end
	begin
	    ta: term_arr := term_seq$s2a(proof_method$value_cases(conj.method))
	    for k: int in term_arr$indexes(ta) do
		ta[k] := system$flatten_term(ta[k], i.sys)
		end
	    conj.method := proof_method$make_cases(term_seq$a2s(ta))
	    end except when wrong_tag: end
	end reflatten

    
    % Sets the proof method for the current conjecture to "m".  Signals 
    % "no_conjecture" if there is no conjecture.  Signals "illegal" if the
    % proof method cannot be applied to the current conjecture.

    reset_method = proc (i: interactive, m: proof_method)
		     signals (illegal, no_conjecture)
	pr: rep := down(i.prover)
	conj: conjecture := conj_arr$top(pr.stack)
	   except when bounds: signal no_conjecture end
	statistics$start_prover()
	if ~is_valid(conj.conj, conj.normalized, m) then 
	   statistics$stop_prover()
	   signal illegal
	   end
	remember_progress(i)
	conj.method := m
	statistics$stop_prover()
	end reset_method


    % Sets "box_checking" to "b".
    
    set_box_checking = proc (b: bool)
	box_checking := b
	end set_box_checking
    
    
    % Sets the list of default proof methods for conjectures that are formulas
    % to "pm".
    
    set_default_methods = proc (pr: cvt, pm: npm_seq)
	conj_arr$top(pr.stack).default_methods := pm
	   except when bounds: pr.outer_methods := pm end
	end set_default_methods

    
    % Sets the indentation for the script file.
    
    set_indentation = proc (i: interactive)
	pr: rep := down(i.prover)
	i.io.script_indent := indent_for_proof(pr, conj_arr$size(pr.stack))
	end set_indentation

    
    % Returns "true" if "m" can be applied to "f".
    
    valid_method = proc (m: proof_method, f: fact) returns (bool)
	fo: formula := fact$value_eq(f)
	   except when wrong_tag: fo := inconsistency end
        return(is_valid(f, fo, m))
	end valid_method
    
    
    
    % (Experimental procedure) Attempts to finish a proof by showing that it is
    % impossible to satisfy the ground facts in the system together with (an
    % instantiation of) the negation of the current conjecture.

    zap = proc (i: interactive)
	statistics$start_prover()
	remember_progress(i)
	set_goals(i)
	   except when diamond_error: statistics$stop_prover()
				      return
		  end 
	% If we get here, either all conjectures have been proved or we are
	% attempting to prove a formula by normalization or explicit commands.
	pr: rep := down(i.prover)
	c: conjecture := conj_arr$top(pr.stack)
	   except when bounds: statistics$stop_prover()
			       return
	          end
	if c.normalized.formula.has_quantifiers then
	   printer$text(i.p, "Cannot zap formula with quantifiers.\n")
	   statistics$stop_prover()
	   return
	   end
	nf: formula, cs: op_set := 
	    make_instantiated_negation(c, i.sys, i.symtab)
	proved: bool := false
	%fos: fo_seq := system$satisfy(i.sys, nf, i.symtab)
 	a: model := system$zap(i.sys, nf, i.symtab)
	   except when interrupt:
		       printer$text(i.p, "\nInterrupt...\n")
	               statistics$stop_prover()
		       return
		  when none: proved := true
		  when overflow:
		       printer$text(i.p, "\nCommand aborted: overflow\n")
		       statistics$stop_prover()
		       return
		  end
	if proved
	   then report_proof(i, "by exhaustive search for counterexample")
		set_goals(i)
		   except when diamond_error:  % diamond check failed
			       statistics$stop_prover()
			       return
			  end
		if pr.box_error then
		   statistics$stop_prover()
		   return
		   end
		make_inferences(i, stabilize_task_mode)
		   except when proved:
			  when interrupt:
			       statistics$stop_prover()
			       return
			  end
           else printer$text(i.p, "~{\nA possible model for ")
		printer$text(i.p, "the variable-free facts in the system and ")
		printer$text(i.p, "the negation~2I\n")
		formula$print(i.p, nf, i.symtab)
		printer$text(i.p, "~I\nof the current conjecture is:~2I\n")
 		model$print(a, i.p, i.symtab)
		printer$text(i.p, "~}\n")
	   end
	c := conj_arr$top(pr.stack)
	   except when bounds: statistics$stop_prover()
			       return
	          end
	printer$newline(i.p)
	describe_conjecture(pr, i.p, c, "Suspending proof of ", show_old, 
	                    show_old)
	statistics$stop_prover()
	end zap
    

    % Necessary for "gc_dump".

    _gcd = proc (x: cvt, tab: gcd_tab) returns (int)
	return(rep$_gcd(x, tab))
	end _gcd



    % ***** Internal Procedures and Iterators *****


    % Returns the formula "op(v1, op(v2, v3)) = op(op(v1, v2), v3))".  Enters
    % "v1", "v2", and "v3" in "stab" if necessary.  ASSUMES: "op" is a binary
    % operator and that both of its arguments have the same sort as its range.

    assoc_eq = proc (op: operator, stab: symtab) returns (formula)
	if op.arity ~= 2 cor op.dom[1] ~= op.dom[2] cor op.dom[1] ~= op.rng
	   then fail("prover$%assoc_eq")
	   end
	so: sort := op.dom[1]
	id: identifier := identifier$make_simple(psort$abbreviate(so, 1))
	v: variable := variable${id: id, sort: so}
	vars: var_set := var_set$[v]
	symtab$begin_changes(stab)
	v1: variable := variable$different(so, vars, stab)
	var_set$insert(vars, v1)
	v2: variable := variable$different(so, vars, stab)
	var_set$insert(vars, v2)
	v3: variable := variable$different(so, vars, stab)
	symtab$commit_changes(stab)
	t1: term := term$make_var(v1)
	t2: term := term$make_var(v2)
	t3: term := term$make_var(v3)
	return(formula$create(term2(op_equals(so, stab),
				    term2(op, term2(op, t1, t2), t3),
				    term2(op, t1, term2(op, t2, t3)))))
	end assoc_eq

 
    % Performs box-checking if "box" is "true" and diamond-checking if "box" is
    % false.  When box-checking, sets "i.prover.box_error" true if box-checking
    % is on, input is being executed from a file, and the next nonblank line in
    % the file does not begin with a [].  When diamond-checking, signals
    % "diamond_error" if box-checking is on, input is being executed from a
    % file, and the next nonblank line in the file does not begin with a <>.
    % Prints the correct [] or <> in the script file.

    box_check = proc (i: interactive, box: bool) signals (diamond_error)
	pr: rep := down(i.prover)
	str: stream := stream$create_output()
	p: printer := printer$create_stream(str)
	mark: string
	if box
	   then	mark := "[]"
	   else mark := "<>"
	   end
        printer$text(p, mark)
	printer$text(p, " ~J")
	conj: conjecture := conj_arr$top(pr.stack)
	tagcase conj.kind
	   tag theorem, lemma: printer$text(p, "conjecture")
	   tag subgoal (si: subgoal_info):
	       parent: conjecture := pr.stack[si.parent]
	       tagcase parent.method
		  tag a_intro: printer$text(p, "generalization subgoal")
		  tag and:     printer$text(p, "/\\ subgoal")
		  tag cases:   printer$text(p, "case ")
			       formula$print(p, conj.hyps[1], i.symtab)
				  except when bounds:
					      printer$text(p, "justification")
					 end
		  tag cond:    printer$text(p, "conditional subgoal")
		  tag contra:  printer$text(p, "contradiction subgoal")
		  tag dr:      printer$text(p, "deduction rule")
		  tag e_intro: printer$text(p, "specialization subgoal")
		  tag iff:     printer$text(p, "<=> subgoal")
		  tag implies: printer$text(p, "=> subgoal")
		  tag induct:  if fo_arr$empty(conj.hyps)
				  then printer$text(p, "basis subgoal")
				  else printer$text(p, "induction subgoal")
				  end
		  tag ir:      printer$text(p, "induction rule")
		  tag ot:      printer$text(p, "operator theory")
		  tag default, 
		      none,
		      normal:      fail("prover$%box_check")
		  end
	   end
	printer$end_of_output(p)
	annotation: string := stream$get_contents(str)
        iodev$write_script(i.io, string_replace_char(annotation, '\n', "\n%%"))
	stream$close(str)
	if box_checking cand ~pr.box_error cand iodev$reading_script(i.io) then
	   s: string := ""
	   prompt: string := mark || "? "
	   while string$empty(s) cand iodev$reading_script(i.io) do
	       s := trim_head(iodev$gets(i.io, prompt, ""))
	       end except when end_of_file, not_possible: end
	   if string$substr(s, 1, 2) = mark
	      then iodev$strike_script(i.io)
	      else printer$error(i.p)
		   printer$text(i.p, "\nError: missing " || mark || ".\n")
		   iodev$write_script(i.io, "%% ERROR: missing " || mark || ".")
		   if box
		      then pr.box_error := true
		      else signal diamond_error
		      end
	      end
	   end
	end box_check
    
    
    % Returns the formula "op(v1, v2) = op(v2, v1)".  Enters "v1" and "v2 in
    % "stab" if necessary.  ASSUMES: "op" is a binary operator and that both of
    % its arguments have the same sort.

    commutative_eq = proc (op: operator, stab: symtab) returns (formula)
	if op.arity ~= 2 cor op.dom[1] ~= op.dom[2] then
	   fail("prover$%commutative_eq")
	   end
	so: sort := op.dom[1]
	id: identifier := identifier$make_simple(psort$abbreviate(so, 1))
	v: variable := variable${id: id, sort: so}
	vars: var_set := var_set$[v]
	symtab$begin_changes(stab)
	v1: variable := variable$different(so, vars, stab)
	var_set$insert(vars, v1)
	v2: variable := variable$different(so, vars, stab)
	symtab$commit_changes(stab)
	t1: term := term$make_var(v1)
	t2: term := term$make_var(v2)
	return(formula$create(term2(op_equals(op.rng, stab),
				    term2(op, t1, t2),
				    term2(op, t2, t1))))
	end commutative_eq


    % Prints a description of "conj" beginning with "msg" on "p".  Shows the
    % original (reduced) forms of "conj" if "orig" ("reduced") is "show_always"
    % or if it is "show_old" and the conjecture has not been described in the
    % last 50 lines of output.
    
    describe_conjecture = proc (pr: rep, p: printer, conj: conjecture, 
				msg: string, orig, reduced: to_show)
	n: int := 1
	conj1: conjecture := conj
	while true do
	    tagcase conj1.kind
	       tag lemma (c: int):             conj1 := pr.stack[c]
	       tag subgoal (si: subgoal_info): conj1 := pr.stack[si.parent]
	       tag theorem: break
	       end
	    n := n + 1
	    end 
	if n > 1 then msg := msg || "level " || int$unparse(n) || " " end
	tagcase conj.kind
	   tag theorem: 		   msg := msg || "conjecture"
	   tag lemma:   		   msg := msg || "lemma"
	   tag subgoal (si: subgoal_info): 
	       msg := msg || subgoal_name(pr, conj, si)
	   end
	printer$text(p, "~{")
	printer$puts(p, string$c2s(upper(msg[1])))
	printer$text(p, string$rest(msg, 2))
	begin
	    nm: name := get_fact_name(conj.conj)
	    printer$text(p, " ")
	    name$print(p, nm)
	    end except when none: end
	if (to_show$is_old(orig) cand p.total_lines > conj.printed + 50)
	     cor to_show$is_always(orig) then
	   printer$text(p, ":~2I ")
	   stab: symtab := conj.symtab
	   tagcase conj.conj
	      tag dr (dr: deduction_rule):
		  deduction_rule$print(p, dr, stab)
	      tag eq (fo: formula):
		  formula$print(p, fo, stab)
		  if ~to_show$is_never(reduced) 
		       cand ~formula$same_object(fo, conj.normalized) then
		     printer$text(p, "\nCurrent subgoal:~4I~1F")
		     formula$print(p, conj.normalized, stab)
		     end
	      tag ir (ir: induction_rule): induction_rule$print(p, ir, stab)
	      tag ot (ot: op_theory):      op_theory$print(p, ot, stab)
	      tag rr (rr: rewrite_rule):   fail("prover$%display")
	      end
	   conj.printed := p.total_lines
	   end
	printer$text(p, "~}\n")
	end describe_conjecture


    % Pops all conjectures off "source" and pushes them onto "pr.stack".
    % ENHANCE: Have "pr.stack" share subgoals with parent.
    
    enter_subgoals = proc (pr: rep, source: conj_arr)
	while true do
	    conj_arr$addh(pr.stack, conj_arr$remh(source))
	    end except when bounds: end
	pr.new_conjecture := true
	end enter_subgoals
	    

    % Reports that "fo" is inconsistent, then pops the proof stack back to a
    % conjecture that introduced a hypothesis and reports that the conjecture
    % has been proved.  Clears the proof stack if there is no such conjecture.

    handle_inconsistency = proc (i: interactive, fo: formula)
	pr: rep := down(i.prover)
	printer$text(i.p, "\n~{Formula ")
	begin 
	    name$print(i.p, fo.name)
	    printer$text(i.p, "~2I, ")
	    end except when none: end
	formula$print(i.p, fo, i.symtab)
	i.p.indent := 0
	printer$text(i.p, ", is inconsistent.~}\n")
	stack: conj_arr := pr.stack
	while true do  % Look for hypothesis that introduced inconsistency
	    conj: conjecture := conj_arr$top(stack)
	    conj.proved := true
	    parent_no: int
	    tagcase conj.kind
	       tag theorem, lemma:
	           printer$text(i.p, "\n~{Deleted ")
		   print_name(i.p, conj)
		   printer$text(i.p, ".~}\n")
		   parent_no := conj_arr$size(stack) - 1
	       tag subgoal (si: subgoal_info):
	           parent_no := si.parent
		   tagcase stack[parent_no].method
		      tag cases:
		          if ~fo_arr$empty(conj.hyps) then
			     report_proof(i, "by impossible case")
			     break
			     end
		      tag contra:     
			  report_proof(i, "by detecting an inconsistency")
			  break
		      tag cond, dr, iff, implies:    
			  report_proof(i, "by inconsistent hypothesis")
			  break
		      tag and, induct, ir, normal, ot, a_intro, e_intro:
			  % NOTE: Since the basis step for a proof by induction
			  % is proved before the induction step, the induction
			  % hypotheses are conservative extensions of "i.sys".
		      tag default, none: fail("prover$handle_inconsistency")
		      end
	       end
	    % Look further for inconsistency
	    while conj_arr$size(pr.stack) > parent_no do
		if interactive$get_experimental()
		   then pop_system(i.sys, conj_arr$remh(stack))
		   else conj_arr$remh(stack)
		   end
		end
	    if ~interactive$get_experimental() then set_state(i) end
	    end except when bounds: end
	pr.new_conjecture := true
	end handle_inconsistency


    % Returns the number of spaces to indent the proof of "conj" in the script.

    indent_for_proof = proc (pr: rep, conj_no: int) returns (int)
	n: int := 0
	while conj_no > 0 do
	    n := n + box_indent
	    tagcase pr.stack[conj_no].kind
	       tag lemma (c: int):             conj_no := c
	       tag subgoal (si: subgoal_info): conj_no := si.parent
	       tag theorem: break
	       end
	    end 
        return(n)
	end indent_for_proof


    % Returns "true" if "m" can be applied to "f" (or to "fo", if "f" is a
    % formula.
    
    is_valid = proc (f: fact, fo: formula, m: proof_method) returns (bool)
	tagcase m
	   tag a_intro (sigma: substitution): 
	       if ~fact$is_eq(f) then return(false) end
	       v: variable := var_set$any_element(sigma.domain)
	       vt: term := sigma[v]
	       fo := exists_elimination(fo, v, vt, false, dummy_op_sys, 
		                        dummy_symtab)
		  except others: return(false) end
	       return(true)
	   tag and:     return(fact$is_eq(f) cand fo.formula.root = op_and())
	   tag cases:   return(fact$is_eq(f))
	   tag cond:	if ~fact$is_eq(f) then return(false) end
	   	        if is_op_if(fo.left.root) then
			   return(~is_op_if(fo.right.root))
			      except when wrong_tag: return(true) end
			   end except when wrong_tag: end
			return(is_op_if(fo.right.root))
			   except when wrong_tag: return(false) end
	   tag contra:  return(fact$is_eq(f))
	   tag default: return(true)
	   tag dr:      return(fact$is_dr(f))
	   tag e_intro (sigma: substitution): 
	       if ~fact$is_eq(f) then return(false) end
	       fo := all_elimination(fo, sigma, false, dummy_op_sys, 
		                     dummy_symtab)
		  except others: return(false) end
	       return(true)
	   tag iff: op: operator := fo.formula.root
	            return(fact$is_eq(f) 
			     cand (op = op_iff() cor op = op_bool_equals()))
	   tag implies: return(fact$is_eq(f)
				 cand fo.formula.root = op_implies())
	   tag induct (ii: induction_info):
	       return(fact$is_eq(f)
			cand var_set$exists(fo.fvars, ii.var))
	   tag ir:      return(fact$is_ir(f))
	   tag none:    return(true)
	   tag normal:  return(fact$is_eq(f))
	   tag ot:      return(fact$is_ot(f))
	   end except when wrong_tag: return(false) end
	end is_valid

    
    % Returns the negation of the conjecture "c", with all variables replaced
    % by fresh constants.  Also returns the set of fresh constants.  ASSUMES:
    % "c" is a conjecture that is a formula.

    make_instantiated_negation = proc (c: conjecture, sys: system, 
				       stab: symtab) 
				   returns (formula, op_set)
	fo: formula := fact$value_eq(c.conj)
	   except when wrong_tag: fail("prover$%make_instantiated_negation") 
		  end
        t: term := term1(op_not(), c.normalized.formula)
	if var_set$empty(t.fvars) then return(formula$create(t), op_set$[]) end
	avoid: op_set := sys.ops + t.ops
	sigma: substitution := plug_variables(t, avoid, stab)
	t := substitution$apply(sigma, t, stab)
	return(formula$create(system$flatten_term(t, sys)), sigma.ops)
	end make_instantiated_negation


    % Returns the formula "false", with a name of "Inconsistency".
    
    make_inconsistency = proc () returns (formula)
	fo: formula := formula$create(term_false())
	fo.name := name$create("Inconsistency")
	return(fo)
	end make_inconsistency


    % Returns a conjecture that involves proving "fo" as the "n"th subgoal for
    % node "parent_no" in the proof forest.
    
    new_subgoal = proc (i: interactive, fo: formula, n, parent_no: int)
		    returns (conjecture)
	xx: int
	if interactive$get_experimental()
	   then xx := 4
	   else xx := 3
	   end
	inits: init_arr := init_arr$predict(1, xx)
	init_arr$addh(inits, init$make_diamond(nil))
	si: subgoal_info := subgoal_info${goal: n, parent: parent_no}
	parent: conjecture := down(i.prover).stack[parent_no]
	return(conjecture${ai: ai_settings${active: false, immune: immunity_on},
			   conj: fact$make_eq(fo),
			   default_methods: parent.default_methods,
			   hyps: fo_arr$[],
			   inits: inits,
			   kind: node_kind$make_subgoal(si),
			   method: proof_method$make_default(nil),
			   normalized: fo,
			   pops: 0,			% Experimental
			   printed: i.io.total_lines,
			   proved: false,
			   symtab: i.symtab,
			   sys: i.sys})
	end new_subgoal


    % Returns a substitution that replaces the free variables in "t" by
    % distinct constants not in "ops".  Enters these constants in "stab" and
    % adds them to "ops".
    
    plug_variables = proc (t: term, ops: op_set, stab: symtab)
		       returns (substitution)
	sigma: substitution := substitution$[]
	symtab$begin_changes(stab)
	for v: variable in var_set$elements(t.fvars) do
	    op: operator := operator$from_variable(v, ops, stab)
	    sigma[v] := term0(op)
	    op_set$insert(ops, op)
	    end
	symtab$commit_changes(stab)
	return(sigma)
	end plug_variables
    
    
    % Pops "sys" as many times as it was pushed during work on "c".
    
    pop_system = proc (sys: system, c: conjecture)
	if ~interactive$get_experimental() then fail("prover$pop_system") end
	for i: int in int$from_to(1, c.pops) do system$pop(sys) end
	sys.goal := goal$make_none(nil)
	end pop_system


    
    % Prints the cases involved in the proof of "conj".  Prints nothing if
    % "conj" is not being proved by cases.
    
    print_cases = proc (p: printer, conj: conjecture)
	ts: term_seq := proof_method$value_cases(conj.method)
	   except when wrong_tag: return end
	printed: bool := false
	for t: term in term_seq$elements(ts) do
	    if printed then printer$text(p, ", ") end
	    term$print(p, t, conj.symtab)
	    printed := true
	    end
	end print_cases


    % Prints the constants in "ops".  Invoked when subgoals are created for a
    % proof.
    
    print_constants = proc (pr: printer, label: string, ops: op_set, 
	    		    stab: symtab)
        if op_set$size(ops) = 0 then return end
        printer$text(pr, label)
	if op_set$size(ops) = 1 
	   then printer$text(pr, " constant: ~2I~{")
	   else printer$text(pr, " constants: ~2I~{")
	   end
        printed: bool := false
        for op: operator in op_set$elements(ops) do
	    if printed then printer$text(pr, ", ") end
	    operator$print(pr, op, stab)
	    printed := true
	    end
	printer$text(pr, "~}~I\n")
	end print_constants


    % Prints the hypotheses in "hyps".  Invoked when subgoals are created for a
    % proof.
    
    print_hypotheses = proc (pr: printer, label: string, hyps: fo_arr,
			     stab: symtab)
	if fo_arr$empty(hyps) then return end
        if string$empty(label)
	   then printer$puts(pr, "H")
	   else printer$text(pr, label)
		printer$text(pr, " h")
	   end
	if fo_arr$size(hyps) = 1 
	   then printer$text(pr, "ypothesis:\n")
	   else printer$text(pr, "ypotheses:\n")
	   end
	for h: formula in fo_arr$elements(hyps) do
	    show[formula](pr, h, stab)
	    end
	end print_hypotheses


    % Prints a description of the current method of proof for "conj".

    print_method = proc (p: printer, conj: conjecture, word: string)
	tagcase conj.method
	   tag a_intro: printer$text(p, "by generalization")
	   tag and:     printer$text(p, word)
	   		printer$text(p, "/\\")
	   tag cases:   printer$text(p, "by cases ")
	   tag cond:    printer$text(p, word)
	   		printer$text(p, "`if'")
	   tag contra:  printer$text(p, "by contradiction")
	   tag default: printer$text(p, "by default method")
	   tag dr:      printer$text(p, word)
	   		printer$text(p, "deduction rule")
	   tag e_intro: printer$text(p, "by specialization")
	   tag iff:     printer$text(p, word)
	   		printer$text(p, "<=>")
	   tag implies: printer$text(p, word)
	   		printer$text(p, "=>")
	   tag induct (ii: induction_info):
	       printer$text(p, "by ")
	       if ii.depth > 1 then
		  printer$text(p, "depth ")
		  printer$text(p, int$unparse(ii.depth))
		  printer$text(p, " ")
		  end
	       if induction_rule$is_structural(ii.rule)
		  then printer$text(p, "structural ")
		  else printer$text(p, "well founded ")
		  end
	       printer$text(p, "induction on `")
	       variable$print(p, ii.var, conj.symtab)
	       printer$text(p, "'")
	   tag ir:      printer$text(p, word)
	   		printer$text(p, "induction rule")
	   tag none:    printer$text(p, "by explicit commands")
	   tag normal:  printer$text(p, "by normalization")
	   tag ot:      printer$text(p, word)
	   		printer$text(p, "operator theory")
	   end
	end print_method


    % Prints a name for "conj" of the form
    %
    %      Conjecture <name>
    %      Lemma <name>
    %      Subgoal <name>    

    print_name = proc (p: printer, conj: conjecture)
	tagcase conj.kind
	   tag theorem: printer$text(p, "Conjecture ")
	   tag lemma:   printer$text(p, "Lemma ")
	   tag subgoal: printer$text(p, "Subgoal ")
	   end
	name$print(p, get_fact_name(conj.conj))
	end print_name
    
    
    % Prints a message saying that subgoal(s) were introduced for "conj".
    
    print_subgoal_heading = proc (p: printer, conj: conjecture)
	printer$text(p, "\n~{Creating subgoals for proof ")
	print_method(p, conj, "of ")
	printer$text(p, "~}\n")
	end print_subgoal_heading
    

    % Prints the formulas that must be proved to establish the "subgoals".
    % Invoked when subgoals are created for a proof.
    
    print_subgoals = proc (pr: printer, label: string, subgoals: conj_arr, 
	                   low: int)
        if conj_arr$empty(subgoals) then return end
        if ~string$empty(label) then
	   printer$text(pr, label)
	   if conj_arr$size(subgoals) > 1 then printer$puts(pr, "s") end
	   printer$text(pr, ":\n")
	   end
        index: int := low
	for c: conjecture in conj_arr$elements(subgoals) do
	    printer$text(pr, "~{~ ~ ")
	    if low ~= 0 then
	       printer$text(pr, "~{Subgoal~ ")
	       printer$text(pr, int$unparse(index))
	       printer$text(pr, ":~ ~}~4I")
	       end
	    formula$print(pr, fact$value_eq(c.conj), c.symtab)
	    printer$text(pr, "~}\n")
	    index := index + 1
	    end
	lines: int := pr.total_lines
	for c: conjecture in conj_arr$elements(subgoals) do
	    c.printed := lines
	    end
	end print_subgoals

    
    % Remembers any progress made by the system on the current conjecture.
    
    remember_progress = proc (i: interactive)
	pr: rep := down(i.prover)
	conj: conjecture := conj_arr$top(pr.stack)
	   except when bounds: return end
	conj.normalized := goal$value_exists(i.sys.goal)
	   except when wrong_tag: return end
	i.sys.goal := goal$make_none(nil)
	end remember_progress
	    

    % Reports that the current conjecture has been proved by "action", pops the
    % conjecture off "i.prover.stack", and adds it to the system.  If "action"
    % is the empty string, computes it from the proof method for the
    % conjecture.  Restores the system (and symbol table if not experimental)
    % for what becomes the current conjecture.  Sets "i.prover.box_error" true
    % if box-checking fails.

    report_proof = proc (i: interactive, action: string) 
	pr: rep := down(i.prover)
	conj: conjecture := conj_arr$top(pr.stack)
	   except when bounds: fail("prover$%report_proof") end
	printer$text(i.p, "\n~{")
	describe_conjecture(pr, i.p, conj, "", show_old, show_never)
	printer$text(i.p, "[] ~JProved ")
	if string$empty(action)
	   then print_method(i.p, conj, "")
	 	print_cases(i.p, conj)
	   else printer$text(i.p, action)
	   end
	printer$text(i.p, ".~}\n")
	box_check(i, true)
	conj_arr$remh(pr.stack)
	if interactive$get_experimental() 
	   then system$pop(i.sys)
		% We only pop "i.sys" once, even if "conj.pops > 1", because
		% "conj.pops" is only for use by "cancel".
	   else set_state(i)
	   end
	i.sys.goal := goal$make_none(nil)
	pr.new_conjecture := true
	tagcase conj.kind
	   tag lemma, theorem:
	       tagcase conj.conj
		  tag dr (dr: deduction_rule):
		      system$add_deduction_rule(i.sys, dr, conj.ai)
		  tag eq (fo: formula):
		      system$add_formula(i.sys, fo, conj.ai, true)
		  tag ir (ir: induction_rule):
		      system$add_induction_rule(i.sys, ir)
		      % FIX: handle inconsistency
		      for fo: formula
			    in induction_rule$free_facts(ir, i.symtab) do
			  system$add_formula(i.sys, fo, conj.ai, true)
			  end except when not_free: end
		  tag ot (ot: op_theory):
		      system$add_op_theory(i.sys, ot)
		      % ENHANCE: handle inconsistent op theories
		  tag rr (rr: rewrite_rule):
		      fail("prover$%report_proof")
		  end except when subsumed, inconsistent (*): end
 	   tag subgoal (si: subgoal_info):
 	       if si.parent = conj_arr$size(pr.stack) then
 		  conj_arr$top(pr.stack).proved := true
 		  end
 	   end
	end report_proof


    % If "c.method" is "default", sets it to the first proof method in
    % "c.default_methods" that is applicable to "c", or to the appropriate
    % proof method for proving a non-formula.  If there is no such method, sets
    % "c.method" to "none".
    
    set_proof_method = proc (pr: rep, c: conjecture)
	tagcase c.conj
	   tag dr:     c.method := proof_method$make_dr(nil)
	   tag ir:     c.method := proof_method$make_ir(nil)
	   tag ot:     c.method := proof_method$make_ot(nil)
	   tag eq, rr:
	   end
	if ~proof_method$is_default(c.method) then return end
	for m: named_proof_method in npm_seq$elements(c.default_methods) do
	    if is_valid(c.conj, c.normalized, m.pm) then
	       c.method := m.pm
	       return
	       end
	    end
	c.method := proof_method$make_none(nil)
	end set_proof_method
    
    
    % Sets "i.sys" (if not experimental) and "i.symtab" to the state associated
    % with the current conjecture.
    
    set_state = proc (i: interactive)
	pr: rep := down(i.prover)
	begin
	    c: conjecture := conj_arr$top(pr.stack)
	    i.symtab := c.symtab
	    if ~interactive$get_experimental() then i.sys := c.sys end
	    end except when bounds:
			    i.symtab := pr.outer_symtab
			    if ~interactive$get_experimental() then
			       i.sys := pr.outer_system
			       end
		       end
	i.io.script_indent := indent_for_proof(pr, conj_arr$size(pr.stack))
	end set_state

    
    % Sets "i.sys" and "i.symtab" to the state appropriate for working on the
    % current conjecture.  Copies state and/or adds hypotheses.

    select_context = proc (i: interactive) signals (diamond_error)
	set_state(i)
	pr: rep := down(i.prover)	
	c: conjecture := conj_arr$top(pr.stack)
	   except when bounds: return end
	if pr.new_conjecture cand ~c.proved then
	   printer$newline(i.p)
	   describe_conjecture(pr, i.p, c, "Attempting to prove ", 
	                       show_old, show_old)
	   end
        pr.new_conjecture := false
        diamond_error: bool := false
	sys: system
	if interactive$get_experimental()
	   then sys := i.sys
        	if c.pops = 0 then
	   	   system$push(sys)
	   	   c.pops := c.pops + 1
	   	   end
	   else sys := c.sys
	   end
        while true do
	    tagcase init_arr$reml(c.inits)
	       tag hyps:
		   % ENHANCE: Reconsider ai settings
		   ai: ai_settings := sys.default_ai
		   for h: formula in fo_arr$elements(c.hyps) do
		       system$add_formula(sys, h, ai, false)
		       end
		   tracer$hypothesized(c.hyps)
	       tag copy:
	           if ~interactive$get_experimental() then
		      sys := system$copy(sys)
		      c.sys := sys
		      end
	       	   c.symtab := symtab$copy_ids(c.symtab)
	       tag diamond:
	           box_check(i, false)
		      except when diamond_error: diamond_error := true end
 	       tag push:
	           if ~interactive$get_experimental() then
		      fail("prover$select_context")
		      end
 	           system$push(i.sys)
 		   c.pops := c.pops + 1
	       end
	    end except when bounds: end
	if ~interactive$get_experimental() then
	   i.sys := sys
	   i.symtab := c.symtab
	   end
	if diamond_error then signal diamond_error end
	end select_context
    
    
    % Creates goals for the next proof attempt.
    
    set_goals = proc (i: interactive) signals (diamond_error)
	select_context(i)
	   resignal diamond_error
	pr: rep := down(i.prover)
	while true do
	    c: conjecture := conj_arr$top(pr.stack)
	       except when bounds: return end
	    if c.proved then return end
	    % Determine what to try if "c" has the default proof method.
	    set_proof_method(pr, c)
	    % Create subgoals, if appropriate.
	    tagcase c.method
	       tag a_intro (s: substitution):	start_a_intro_proof(i, s)
	       tag and:                         start_and_proof(i)
	       tag cases (cases: term_seq):     start_case_proof(i, cases)
	       tag cond:			start_if_proof(i)
	       tag contra:                      start_contra_proof(i)
	       tag default:		        fail("prover$%set_subgoals")
	       tag dr:				start_dr_proof(i)
	       tag e_intro (s: substitution):	start_e_intro_proof(i, s)
	       tag iff:                         start_iff_proof(i)
	       tag implies:                     start_implies_proof(i)
	       tag induct (ii: induction_info): start_inductive_proof(i, ii)
	       tag ir:				start_ir_proof(i)
	       tag normal:                      return
	       tag none: 			return
	       tag ot:				start_ot_proof(i)
	       end resignal diamond_error
	    end
	end set_goals

    
    % Creates subgoal for proof by universal quantifier introduction.
    
    start_a_intro_proof = proc (i: interactive, sigma: substitution) 
			    signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	if ~fact$is_eq(parent.conj) then
	   fail("prover$%start_a_intro_proof")
	   end
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	v: variable := var_set$any_element(sigma.domain)
	vt: term := sigma[v]
	fo: formula := parent.normalized
	fo1: formula := exists_elimination(fo, v, vt, false, dummy_op_sys, i.symtab)
	   except others: fail("start_a_intro_proof") end
	fo1 := system$flatten_eq(fo1, i.sys)
	c: conjecture := new_subgoal(i, fo1, 0, parent_no)
        subgoals: conj_arr := conj_arr$[c]
	print_subgoal_heading(i.p, parent)
	print_subgoals(i.p, "Subgoal", subgoals, 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_a_intro_proof


    % Creates subgoals for proof of a conjunction.
    
    start_and_proof = proc (i: interactive) signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	if ~fact$is_eq(parent.conj) then
	   fail("prover$%start_and_proof")
	   end
	conjunct: term := parent.normalized.formula
	if conjunct.root ~= op_and() then
	   fail("prover$%start_and_proof")
	   end except when wrong_tag: fail("prover$%start_and_proof") end
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	% NOTE: This copy will be used for the last subgoal; earlier subgoals
	% make copies of it.
	n_subgoals: int := term_seq$size(conjunct.args)
        subgoals: conj_arr := conj_arr$predict(1, n_subgoals)
	tn: int := 0
	for t: term in term_seq$elements(conjunct.args) do
	    tn := tn + 1
	    fo: formula := formula$create(t)
	    c: conjecture := new_subgoal(i, fo, tn, parent_no)
	    if tn < n_subgoals then init_arr$addh(c.inits, copy_state) end
	    conj_arr$addh(subgoals, c)
	    end
	print_subgoal_heading(i.p, parent)
	print_subgoals(i.p, "", subgoals, 1)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_and_proof


    % Creates subgoals for a proof-by-cases of the current conjecture.

    start_case_proof = proc (i: interactive, ts: term_seq) 
			 signals (diamond_error)
	
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	if ~fact$is_eq(parent.conj) then
	   fail("prover$%start_case_proof") 
	   end
	case_root: name := symtab$extended_root_name(i.symtab, "CaseHyp")
	case_name: name := symtab$new_subname(i.symtab, case_root)
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	% NOTE: This copy will be used either for the case disjunct or for the 
	% last case; earlier cases make copies of it.
        n_subgoals: int := term_seq$size(ts)
	
	% Create subgoal for case disjunct, if necessary.
	cases: term
	c1: conjecture
	prove_disjunct: bool := n_subgoals > 1
	if prove_disjunct
	   then cases := term$make_funct(op_or(), ts)
		% We preserve order of cases by not flattening this term yet.
		case_fo: formula := formula$create(cases)
		c1 := new_subgoal(i, case_fo, 0, parent_no)
		c1.normalized := 
		    formula$create(system$flatten_term(cases, i.sys))
		% ENHANCE: Avoid copying state if case hypothesis normalizes
		% to an identity.
		i.symtab := symtab$copy_ids(i.symtab)
		if ~interactive$get_experimental() then
		   i.sys := system$copy(i.sys)
		   end
	   else ts := term_seq$addh(ts, term$make_funct(op_not(), ts))
		cases := term$make_funct(op_or(), ts)
		n_subgoals := 2
	   end
	
	% Create subgoal for proof in each case
	subgoals: conj_arr := conj_arr$predict(1, n_subgoals)
	hyps: fo_arr := fo_arr$predict(1, n_subgoals)
	avoid: op_set := i.sys.ops + parent.normalized.ops + cases.ops
	sigma: substitution := plug_variables(cases, avoid, i.symtab)
	conclusion: formula := 
	    system$instantiate_formula(parent.normalized, sigma, i.sys, i.symtab)
     	   except when same: conclusion := formula$unname(parent.normalized) 
	          end
	tn: int := 0
	for t: term in term_seq$elements(ts) do
	    tn := tn + 1
	    t := substitution$apply(sigma, t, i.symtab)
	    hypothesis: formula := formula$create(system$flatten_term(t, i.sys))
	    hypothesis.name := symtab$new_subname(i.symtab, case_name)
	    conclusion1: formula := formula$unname(conclusion)
	    c: conjecture := new_subgoal(i, conclusion1, tn, parent_no)
	    if tn < n_subgoals then init_arr$addh(c.inits, copy_state) end
	    init_arr$addh(c.inits, add_hyps)
	    fo_arr$addh(c.hyps, hypothesis)
	    conj_arr$addh(subgoals, c)
	    fo_arr$addh(hyps, hypothesis)
	    end

	if prove_disjunct then n_subgoals := n_subgoals + 1 end
	print_subgoal_heading(i.p, parent)
	if prove_disjunct then
	   print_subgoals(i.p, "Case justification subgoal", conj_arr$[c1], 0)
	   end
        print_constants(i.p, "New", sigma.ops, i.symtab)
	print_hypotheses(i.p, "Case", hyps, i.symtab)
	printer$text(i.p, "Same subgoal for all cases:\n~{~ ~ ")
	formula$print(i.p, fact$value_eq(subgoals[1].conj), i.symtab)
	printer$text(i.p, "~}\n")
	enter_subgoals(pr, subgoals)
	if prove_disjunct then conj_arr$addh(pr.stack, c1) end
	select_context(i)
	   resignal diamond_error
	end start_case_proof


    % Creates subgoal for a proof by contradiction of the current conjecture.

    start_contra_proof = proc (i: interactive) signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end

	% Create hypothesis for subgoal.
	contra_root: name := symtab$extended_root_name(i.symtab, "ContraHyp")
	hypothesis: formula, new_consts: op_set := 
	    make_instantiated_negation(parent, i.sys, i.symtab)
	hypothesis.name := symtab$new_subname(i.symtab, contra_root)
	
	fo1: formula := formula$create(term_false())
	c: conjecture := new_subgoal(i, fo1, 0, parent_no)
	init_arr$addh(c.inits, add_hyps)
	fo_arr$addh(c.hyps, hypothesis)
	
	subgoals: conj_arr := conj_arr$[c]
	print_subgoal_heading(i.p, parent)
	print_constants(i.p, "New", new_consts, i.symtab)
	print_hypotheses(i.p, "", c.hyps, i.symtab)
	print_subgoals(i.p, "Only subgoal", subgoals, 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_contra_proof


    % Creates subgoal for proof of a deduction rule.
    
    start_dr_proof = proc (i: interactive) signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	dr: deduction_rule := fact$value_dr(parent.conj)
	   except when wrong_tag: fail("prover$%start_dr_proof") end
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	fo: formula := deduction_rule$dr2e(dr)
	c: conjecture := new_subgoal(i, fo, 0, parent_no)
        subgoals: conj_arr := conj_arr$[c]
	print_subgoal_heading(i.p, parent)
	print_subgoals(i.p, "Subgoal", subgoals, 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_dr_proof


    % Creates subgoal for proof by existential quantifier introduction.
    
    start_e_intro_proof = proc (i: interactive, sigma: substitution) 
			    signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	if ~fact$is_eq(parent.conj) then
	   fail("prover$%start_e_intro_proof")
	   end
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	fo: formula := parent.normalized
	fo1: formula := all_elimination(fo, sigma, false, dummy_op_sys, i.symtab)
	   except others: fail("start_e_intro_proof") end
	fo1 := system$flatten_eq(fo1, i.sys)
	c: conjecture := new_subgoal(i, fo1, 0, parent_no)
        subgoals: conj_arr := conj_arr$[c]
	print_subgoal_heading(i.p, parent)
	print_subgoals(i.p, "Subgoal", subgoals, 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_e_intro_proof


    % Creates subgoals for proof of a conditional.
    
    start_if_proof = proc (i: interactive) signals (diamond_error)
	own tf: term_seq := term_seq$[truth, falsity]
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	if ~fact$is_eq(parent.conj) then
	   fail("prover$%start_if_proof") 
	   end
	t1: term := parent.normalized.left
	t2: term := parent.normalized.right
	l2r: bool := true
	if ~term$is_funct(t1) cor ~is_op_if(t1.root) then
	   if ~is_op_if(t2.root) then
	      fail("prover$%start_if_proof")
	      end except when wrong_tag: fail("prover$%start_if_proof") end
	   l2r := false
	   t1, t2 := t2, t1
	   end
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	stab: symtab := symtab$copy_ids(i.symtab)
	i.symtab := stab
	
	if_root: name := symtab$extended_root_name(i.symtab, "IfHyp")
	subgoals: conj_arr := conj_arr$predict(1, 2)
	avoid: op_set := i.sys.ops + parent.normalized.ops
	hyp_t: term := t1.args[1]
	sigma: substitution := plug_variables(hyp_t, avoid, stab)
	hyp_t := substitution$apply(sigma, hyp_t, stab)
	hyp_t := system$flatten_term(hyp_t, i.sys)
	t2 := system$flatten_term(substitution$apply(sigma, t2, stab), i.sys)
	for tn: int in int$from_to(2, 3) do
  	    hyp: formula := formula$create(term2(op_iff(), hyp_t, tf[tn-1]))
	    hyp.name := symtab$new_subname(stab, if_root)
	    t: term := substitution$apply(sigma, t1.args[tn], stab)
	    t := system$flatten_term(t, i.sys)
	    con: formula
	    if l2r
	       then con := formula$create(term2(parent.normalized.eqOp, t, t2))
	       else con := formula$create(term2(parent.normalized.eqOp, t2, t))
	       end
	    c: conjecture := new_subgoal(i, con, tn-1, parent_no)
	    if tn = 2 then init_arr$addh(c.inits, copy_state) end
	    init_arr$addh(c.inits, add_hyps)
	    fo_arr$addh(c.hyps, hyp)
	    conj_arr$addh(subgoals, c)
	    end

	print_subgoal_heading(i.p, parent)
	print_constants(i.p, "New", sigma.ops, stab)
	print_hypotheses(i.p, "Case `true'", subgoals[1].hyps, stab)
	print_subgoals(i.p, "Case `true' subgoal", conj_arr$[subgoals[1]], 0)
	print_hypotheses(i.p, "Case `false'", subgoals[2].hyps, stab)
	print_subgoals(i.p, "Case `false' subgoal", conj_arr$[subgoals[2]], 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_if_proof


    % Creates subgoals for proof of an implication.
    
    start_implies_proof = proc (i: interactive) signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	if ~fact$is_eq(parent.conj) then
	   fail("prover$%start_implies_proof") 
	   end
	t: term := parent.normalized.formula
	if t.root ~= op_implies() then
	   fail("prover$%start_implies_proof")
	   end except when wrong_tag: fail("prover$%start_implies_proof") end
	stab: symtab := symtab$copy_ids(i.symtab)
	i.symtab := stab
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	
	implies_root: name := symtab$extended_root_name(stab, "ImpliesHyp")
	sigma: substitution := plug_variables(t.args[1], i.sys.ops + t.ops, 
	    				      stab)
	hyp_t: term := substitution$apply(sigma, t.args[1], stab)
	con_t: term := substitution$apply(sigma, t.args[2], stab)
	hyp: formula := formula$create(system$flatten_term(hyp_t, i.sys))
	hyp.name := symtab$new_subname(stab, implies_root)
	con: formula := formula$create(system$flatten_term(con_t, i.sys))
	c: conjecture := new_subgoal(i, con, 0, parent_no)
	init_arr$addh(c.inits, add_hyps)
	fo_arr$addh(c.hyps, hyp)

	subgoals: conj_arr := conj_arr$[c]
	print_subgoal_heading(i.p, parent)
	print_constants(i.p, "New", sigma.ops, stab)
	print_hypotheses(i.p, "", c.hyps, stab)
	print_subgoals(i.p, "Subgoal", subgoals, 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_implies_proof


    % Creates subgoals for proof of an "<=>".
    
    start_iff_proof = proc (i: interactive) signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_no: int := conj_arr$size(pr.stack)
	if ~fact$is_eq(parent.conj) then
	   fail("prover$%start_implies_proof") 
	   end
	t: term := parent.normalized.formula
	if t.root ~= op_iff() cand t.root ~= op_bool_equals() then
	   fail("prover$%start_iff_proof")
	   end except when wrong_tag: fail("prover$%start_iff_proof") end
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	stab: symtab := symtab$copy_ids(i.symtab)
	i.symtab := stab
	
	implies_root: name := symtab$extended_root_name(stab, "ImpliesHyp")
	sigma: substitution := plug_variables(t, i.sys.ops + t.ops, stab)
	hyp_t: term := substitution$apply(sigma, t.args[1], stab)
	con_t: term := substitution$apply(sigma, t.args[2], stab)
	hyp1: formula := formula$create(system$flatten_term(hyp_t, i.sys))
	hyp1.name := symtab$new_subname(stab, implies_root)
	con1: formula := formula$create(system$flatten_term(con_t, i.sys))
	c1: conjecture := new_subgoal(i, con1, 1, parent_no)
	init_arr$addh(c1.inits, copy_state)
	init_arr$addh(c1.inits, add_hyps)
	fo_arr$addh(c1.hyps, hyp1)
	hyp2: formula := formula$unname(con1)
	hyp2.name := symtab$new_subname(stab, implies_root)
	con2: formula := formula$unname(hyp1)
	c2: conjecture := new_subgoal(i, con2, 2, parent_no)
	init_arr$addh(c2.inits, add_hyps)
	fo_arr$addh(c2.hyps, hyp2)

	subgoals: conj_arr := conj_arr$[c1, c2]
	print_subgoal_heading(i.p, parent)
	print_constants(i.p, "New", sigma.ops, stab)
	print_hypotheses(i.p, "=>", subgoals[1].hyps, stab)
	print_subgoals(i.p, "=> subgoal", conj_arr$[subgoals[1]], 0)
	print_hypotheses(i.p, "<=", subgoals[2].hyps, stab)
	print_subgoals(i.p, "<= subgoal", conj_arr$[subgoals[2]], 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_iff_proof


    % Creates subgoals for a proof by induction of the current conjecture.

    start_inductive_proof = proc (i: interactive, ii: induction_info)
			      signals (diamond_error)
        if induction_rule$is_wf(ii.rule) then
	   start_wf_inductive_proof(i, ii)
	   return
	   end resignal diamond_error
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_fo: formula := fact$value_eq(parent.conj)
	   except when wrong_tag: fail("prover$%start_inductive_proof") end
	parent_fo := parent.normalized
	parent_no: int := conj_arr$size(pr.stack)
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	
	% Formulate subgoals for basis step
	basis: conj_arr := conj_arr$[]
	symtab$begin_changes(i.symtab)
	n_subgoals: int := 0
	for t: term in induction_rule$basis_terms(ii, parent_fo, i.symtab) do
	    n_subgoals := n_subgoals + 1
	    sigma: substitution := substitution$[]
	    sigma[ii.var] := t
	    fo: formula := 
		system$instantiate_formula(parent_fo, sigma, i.sys, i.symtab)
	       except when same: fo := formula$unname(parent_fo) end
	    c: conjecture := new_subgoal(i, fo, n_subgoals, parent_no)
	    init_arr$addh(c.inits, copy_state)
	    conj_arr$addh(basis, c)
	    end
	symtab$commit_changes(i.symtab)
	
	% Formulate induction hypotheses
	i.symtab := symtab$copy_ids(parent.symtab)
	ind_root: name := symtab$extended_root_name(i.symtab, "InductHyp")
	symtab$begin_changes(i.symtab)
	avoid: op_set := i.sys.ops + parent_fo.ops
	cs: op_set := induction_rule$induction_constants(ii, avoid, i.symtab)
	hyps: fo_arr := fo_arr$[]
	for t: term in induction_rule$induction_hyp_terms(ii, cs, parent_fo,
							  i.symtab) do
	    sigma: substitution := substitution$[]
	    sigma[ii.var] := t
	    hyp: formula := 
		system$instantiate_formula(parent_fo, sigma, i.sys, i.symtab)
	       except when same: hyp := formula$unname(parent_fo) end
	    hyp.name := symtab$new_subname(i.symtab, ind_root)
	    fo_arr$addh(hyps, hyp)
	    end
	
	% Formulate subgoals for induction step
	induct: conj_arr := conj_arr$[]
	first: bool := true
	for t: term in induction_rule$induction_eq_terms(ii, cs, parent_fo,
							 i.symtab) do
            n_subgoals := n_subgoals + 1
	    sigma: substitution := substitution$[]
	    sigma[ii.var] := t
	    fo: formula := 
	        system$instantiate_formula(parent_fo, sigma, i.sys, i.symtab)
	       except when same: fo := formula$unname(parent_fo) end
	    c: conjecture := new_subgoal(i, fo, n_subgoals, parent_no)
	    c.hyps := hyps
	    if interactive$get_experimental() 
	       then % FIX: Reintroduce optimization that adds hypotheses only 
	            % when creating the first induction subgoal, and then uses 
		    % copies of that system for each of the other induction 
		    % subgoals.  Special treatment is needed for the last 
		    % subgoal, because we do not need to copy the system when 
		    % we start work on it.  Alternatively, we could formulate 
		    % a single induction step as an implication.
		    init_arr$addh(c.inits, add_hyps)
	            init_arr$addh(c.inits, copy_state)
	       else if first then
		       init_arr$addh(c.inits, add_hyps)
		       first := false
		       end
		    init_arr$addh(c.inits, copy_state)
	       end
	    conj_arr$addh(induct, c)
	    end
	symtab$commit_changes(i.symtab)
	
	% Optimize performance by removing "copy_state" from last subgoal
	last: conjecture := conj_arr$top(induct)
	   except when bounds: last := conj_arr$top(basis) end
        init_arr$remh(last.inits)
	
	print_subgoal_heading(i.p, parent)
	print_subgoals(i.p, "Basis subgoal", basis, 1)
	if fo_arr$empty(hyps)
	   then printer$text(i.p, "The induction step is vacuous.\n")
	   else print_constants(i.p, "Induction", cs, i.symtab)
	        print_hypotheses(i.p, "Induction", hyps, i.symtab)
		print_subgoals(i.p, "Induction subgoal", induct, 
		    	       conj_arr$size(basis) + 1)
	   end
	enter_subgoals(pr, induct)
	enter_subgoals(pr, basis)
	select_context(i)
	   resignal diamond_error
	end start_inductive_proof

    
    % Creates subgoals for proof of an induction rule.
    
    start_ir_proof = proc (i: interactive) signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	ir: induction_rule := fact$value_ir(parent.conj)
	   except when wrong_tag: fail("prover$%start_ir_proof") end
	if induction_rule$is_wf(ir) then
	   start_wf_ir_proof(i)
	   return
	   end resignal diamond_error
        free: bool := induction_rule$is_free_structural(ir)
	parent_no: int := conj_arr$size(pr.stack)
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end

	symtab$begin_changes(i.symtab)
	gen: operator := isGenerated_op(ir.sort, i.symtab)
	vars: var_set := var_set$[]
	v: variable := variable$different(ir.sort, vars, i.symtab)
	con: formula := formula$create(term1(gen, term$make_var(v)))
	c: conjecture := new_subgoal(i, con, 0, parent_no)
	init_arr$addh(c.inits, add_hyps)
	root_name: name := symtab$extended_root_name(i.symtab, "GenHyp")
	ii: induction_info := induction_info${depth: 1, rule: ir, var: v}
	for t: term in induction_rule$basis_terms(ii, con, i.symtab) do
	    h: formula := formula$create(term1(gen, t))
	    h.name := symtab$new_subname(i.symtab, root_name)
	    fo_arr$addh(c.hyps, h)
	    end
	if ir.n_constants > 0 then
	   var_set$insert(vars, v)
	   ops: op_set := op_set$[operator$v2c(v)]
	   for j: int in int$from_to(2, ir.n_constants) do
	       v1: variable := variable$different(v.sort, vars, i.symtab)
	       var_set$insert(vars, v1)
	       op_set$insert(ops, operator$v2c(v1))
	       end
	   ta: term_arr := term_arr$[]
	   for t: term in induction_rule$induction_hyp_terms(ii, ops, con, 
		   					     i.symtab) do
	       term_arr$addh(ta, term1(gen, t))
	       end
	   left: term
	   if term_arr$size(ta) = 1
	      then left := ta[1]
	      else left := term$make_funct(op_and(), term_seq$a2s(ta))
	      end
	   ta := term_arr$[]
	   for t: term in induction_rule$induction_eq_terms(ii, ops, con, 
							    i.symtab) do
	       term_arr$addh(ta, term1(gen, t))
	       end
	   right: term
	   if term_arr$size(ta) = 1
	      then right := ta[1]
	      else right := term$make_funct(op_and(), term_seq$a2s(ta))
	      end
	   left := term2(op_implies(), unrename(left), unrename(right))
	   left := system$flatten_term(left, i.sys)
	   h: formula := formula$create(left)
	   h.name := symtab$new_subname(i.symtab, root_name)
	   fo_arr$addh(c.hyps, h)
	   end
	symtab$commit_changes(i.symtab)
       
	subgoals: conj_arr := conj_arr$[c]
	n_subgoals: int := 1
	subgoals1: conj_arr 
	if free then
	   subgoals1 := conj_arr$[]
	   for fo: formula in induction_rule$free_facts(ir, i.symtab) do
	       c1: conjecture := 
	           new_subgoal(i, fo, conj_arr$size(subgoals1) -1, parent_no)
	       init_arr$addh(c1.inits, copy_state) % ENHANCE: not for last one
	       conj_arr$addh(subgoals1, c1)
	       end
	   n_subgoals := conj_arr$size(subgoals1) + 1
	   end
	print_subgoal_heading(i.p, parent)
	print_hypotheses(i.p, "Induction subgoal", c.hyps, i.symtab)
	if free
	   then print_subgoals(i.p, "Induction subgoal", subgoals, 1)
		print_subgoals(i.p, "Free subgoal", subgoals1, 2)
	   else print_subgoals(i.p, "Induction subgoal", subgoals, 0)
	   end
	if free then enter_subgoals(pr, subgoals1) end
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_ir_proof
    

    % Returns "t" with all constants introduced by "operator$v2c" replaced by
    % the original variables.  NOTE: This procedure has the same effect as
    % "term$get_unrenamed", but does not assume that "t" was produced by
    % "term$get_renamed".  In particular, it handles the variables that occur
    % in terms such as "isGenerated(?cc) => isGenerated(insert(e, ?cc))".

    unrename = proc (t: term) returns (term)
        tagcase t
           tag var: 
	       return(t)
           tag funct:
	       return(term$make_var(operator$c2v(t.root)))
		  except when not_renamed: end
	       new_args: term_arr := term_arr$predict(1, term_seq$size(t.args))
	       for tt: term in term_seq$elements(t.args) do
		   term_arr$addh(new_args, unrename(tt))
		   end
	       return(term$change_args(t, term_seq$a2s(new_args)))
	   tag quant:
	       return(term$make_quant(t.quant, unrename(t.subform)))
	   end
	end unrename

      
    % Creates subgoals for proof of an operator theory.  ASSUMES: theory is AC
    % or commutative.
    
    start_ot_proof = proc (i: interactive) signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	ot: op_theory := fact$value_ot(parent.conj)
	   except when wrong_tag: fail("prover$%start_ot_proof") end
	parent_no: int := conj_arr$size(pr.stack)
	parent.method := proof_method$make_ot(nil)
	i.symtab := symtab$copy_ids(i.symtab)
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	tagcase ot
	   tag empty, free: fail("prover$%start_ot_proof")
	   tag ac, commutative:
	   end
	com: formula := 
            system$flatten_eq(commutative_eq(ot.op, i.symtab), i.sys)
	subgoals: conj_arr
	if op_theory$is_ac(ot) 
	   then c: conjecture := new_subgoal(i, com, 1, parent_no)
		subgoals := conj_arr$[c]
		init_arr$addh(c.inits, copy_state)
		assoc: formula :=
		    system$flatten_eq(assoc_eq(ot.op, i.symtab), i.sys)
		conj_arr$addh(subgoals, new_subgoal(i, assoc, 2, parent_no))
	   else subgoals := conj_arr$[new_subgoal(i, com, 0, parent_no)]
	   end
	n_subgoals: int := conj_arr$size(subgoals)
	print_subgoal_heading(i.p, parent)
	print_subgoals(i.p, "", subgoals, 1)		% FIX!!
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_ot_proof


    % Creates subgoals for a proof by well-founded induction of the current
    % conjecture.

    start_wf_inductive_proof = proc (i: interactive, ii: induction_info)
				 signals (diamond_error)
        if ~induction_rule$is_wf(ii.rule) then 
	   fail("prover$start_wf_inductive_proof")
	   end
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	parent_fo: formula := fact$value_eq(parent.conj)
	   except when wrong_tag: fail("prover$%start_inductive_proof") end
	parent_fo := parent.normalized
	parent_no: int := conj_arr$size(pr.stack)
	stab: symtab := symtab$copy_ids(i.symtab)
	i.symtab := stab
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end
	
	% Formulate induction hypothesis
	ir: induction_rule := ii.rule
	v: variable := ii.var
	avoid: op_set := i.sys.ops + parent.normalized.ops
	symtab$begin_changes(stab)
	vc: operator := operator$from_variable(v, avoid, stab)
	symtab$commit_changes(stab)
	vt: term := term$make_var(v)
	vct: term := term0(vc)
	t: term := parent_fo.formula			% F(v)
	less: term := term2(ir.relation, vt, vct)	% v < vc => F(v)
	hyp: formula := formula$create(term2(op_implies(), less, t))
	ind_root: name := symtab$extended_root_name(stab, "InductHyp")
	hyp.name := symtab$new_subname(stab, ind_root)

	sigma: substitution := substitution$[]
	sigma[v] := vct
	con: formula := 				% F(vc)
	    formula$create(system$instantiate_term(t, sigma, i.sys, stab))
	c: conjecture := new_subgoal(i, con, 0, parent_no)
	init_arr$addh(c.inits, add_hyps)
	fo_arr$addh(c.hyps, hyp)

	subgoals: conj_arr := conj_arr$[c]
	print_subgoal_heading(i.p, parent)
	print_hypotheses(i.p, "", c.hyps, stab)
	print_subgoals(i.p, "Subgoal", subgoals, 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_wf_inductive_proof

    
    % Creates subgoals for proof of a well-founded induction rule.
    
    start_wf_ir_proof = proc (i: interactive) signals (diamond_error)
	pr: rep := down(i.prover)
	parent: conjecture := conj_arr$top(pr.stack)
	ir: induction_rule := fact$value_ir(parent.conj)
	   except when wrong_tag: fail("prover$%start_ir_proof") end
	if ~induction_rule$is_wf(ir) then fail("prover$%start_wf_ir_proof") end
	parent_no: int := conj_arr$size(pr.stack)
	stab: symtab := symtab$copy_ids(i.symtab)
	i.symtab := stab
	if ~interactive$get_experimental() then i.sys := system$copy(i.sys) end

	symtab$begin_changes(stab)
	gen: operator := isGenerated_op(ir.sort, stab)
	vars: var_set := var_set$[]
	v: variable := variable$different(ir.sort, vars, stab)
	vt: term := term$make_var(v)
	var_set$insert_unique(vars, v)
	v1: variable := variable$different(ir.sort, vars, stab)
	symtab$commit_changes(stab)
	v1t: term := term$make_var(v1)
	t: term := term1(gen, vt)
	con: formula := formula$create(t)
	root_name: name := symtab$extended_root_name(stab, "GenHyp")
	t1: term := 
	    term2(op_implies(), term2(ir.relation, v1t, vt), term1(gen, v1t))
	t1 := term$make_quant(quantifier$make_universal(v1, stab), t1)
	hyp: formula := formula$create(term2(op_implies(), t1, t))
	hyp.name := symtab$new_subname(stab, root_name)
	c: conjecture := new_subgoal(i, con, 0, parent_no)
	init_arr$addh(c.inits, add_hyps)
	fo_arr$addh(c.hyps, hyp)
	
	subgoals: conj_arr := conj_arr$[c]
	print_subgoal_heading(i.p, parent)
	print_hypotheses(i.p, "", c.hyps, stab)
	print_subgoals(i.p, "Subgoal", subgoals, 0)
	enter_subgoals(pr, subgoals)
	select_context(i)
	   resignal diamond_error
	end start_wf_ir_proof
    
    
    % Returns an operator with signature "s->Bool" that has an "id" not in
    % "stab" for use in proofs of induction rules.
    
    isGenerated_op = proc (s: sort, stab: symtab) returns (operator)
	gen_sig: signature := signature${dom: sort_seq$[s], rng: bool_sort()}
	gen: operator := operator${id: identifier$make_simple("isGenerated"),
	                           sig: gen_sig}
	n: int := 0
	while true do
	    op1: operator := symtab$lookup_op_id(stab, gen.id)
	       except when missing: break
		      others: 
		      end
	    n := n + 1
	    gen := operator${id: identifier$make_simple("isGenerated" || 
							int$unparse(n)),
	    		     sig: gen_sig}
	    end
	symtab$enter_op(stab, gen)
	   except others: fail("prover$%start_isGeneratedOp") end
	return(gen)
	end isGenerated_op
	      
    
    % Returns a string describing the subgoal "si".

    subgoal_name = proc (pr: rep, conj: conjecture, si: subgoal_info)
		     returns (string)
	num: string := int$unparse(si.goal)
	tagcase pr.stack[si.parent].method
	   tag a_intro: 
	       return("subgoal for proof by generalization")
	   tag and:     
	       return("subgoal for conjunct " || num)
	   tag cases (ts: term_seq):   
	       n: int := int$max(2, term_seq$size(ts))
	       if fo_arr$empty(conj.hyps)
		  then return("subgoal to justify proof by cases")
		  else return("subgoal for case " || num || " (out of " ||
			      int$unparse(n) || ")")
		  end
	   tag cond:
	       return("subgoal " || num || " for proof of `if'")
	   tag contra:  
	       return("subgoal for proof by contradiction")
	   tag default: 
	       return("subgoal")
	   tag dr:      
	       return("subgoal for proof of deduction rule")
	   tag e_intro: 
	       return("subgoal for proof by specialization")
	   tag iff:     
	       return("subgoal " || num || " for proof of <=>")
	   tag implies: 
	       return("subgoal for proof of =>")
	   tag induct (ii: induction_info):
	       msg: string
	       if fo_arr$empty(conj.hyps) then
		  msg := "subgoal " || num || " (basis step)"
		elseif si.goal = 0 then
		  msg := "subgoal for proof by well-founded induction"
		else msg := "subgoal " || num || " (induction step)"
		end
	       return(msg || " for proof by induction on " || 
		      variable$unparse(ii.var))
	   tag ir:      
	       return("subgoal for proof of induction rule")
	   tag none:    
	       return("subgoal")
	   tag normal:  
	       return("subgoal")
	   tag ot:      
	       if si.goal <= 1
		  then return("subgoal for proof of commutativity")
		  else return("subgoal for proof of associativity")
		  end
	   end
	end subgoal_name

    end prover

