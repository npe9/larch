axiom_syntax =
"Legal assertions:                        Examples:\n" ||
"assert                                   assert\n" ||
"  <deduction-rule>;                        when x < y, y < z yield x < z;\n" ||
"  <formula>;                               1 = s(0);\n" ||
"  ac <operator>;                           ac +;\n" ||
"  commutative <operator>;                  commutative relPrime;\n" ||
"  sort <sort> generated by <operators>;    sort Nat generated by 0, s\n" ||
"  sort <sort> partitioned by <operators>   sort Set partitioned by \\in\n" ||
"  ..                                       .."

class_syntax =
"Sample define-class commands:\n" ||
"define-class $<class-name>             displays definition of $<class-name>\n" ||
"define-class $<class-name> <names>     defines $<class-name>\n"

fix_syntax =
"Sample existential quantifier elimination commands:\n" ||
"fix x as c in axiom.3\n" ||
"fix x as sk(y) in *Hyp"

generalize_syntax =
"Sample universal quantifier introduction command:\n" ||
"prove \\A x (f(x) = g(x)) by generalizing x from c"

height_syntax =
"Sample ordering constraints:\n" ||
"register a = b                % a, b have same height in registry\n" ||
"register a > b                % a is higher than b in the registry\n" ||
"register a >= b               % a can be higher than b or have the same height\n" ||
"register (a, b) > (c, d)      % a, b are both higher than c and d\n" ||
"register a > b = c >= (d, e)"

induction_syntax = 
"Sample instructions for proofs by induction:\n" ||
"on x using indRule            % specifies variable and induction rule\n" ||
"on x                          % specifies variable alone\n" ||
"                              % ok if there is only one induction rule\n" ||
"using indRule                 % specifies induction rule alone\n" ||
"                              % ok if there is only one variable\n" ||
"on x depth 5 using indRule    % specifies depth for structural induction"

instantiate_syntax =
"Sample instantiations:\n" ||
"instantiate x by 0 in axioms\n" ||
"instantiate x1 by x1 + x2, x2 by 0 in arith / deduction-rules"

name_syntax1 =
"Sample names for sets of statements:\n" ||
"\n" ||
"Name patterns:\n" ||
"nat                   statements with name-prefix `nat'\n" ||
"*                     all statements\n" ||
"*Hyp                  statements with name-prefix ending in `Hyp'\n" ||
"nat.3                 statement nat.3 and all its descendents\n" ||
"nat.3!                statement nat.3 alone (an exact name)\n" ||
"nat.3.2               statement nat.3.2 and all its descendents\n" ||
"nat.2:5               statements nat.2 through nat.5 and their descendents\n" ||
"nat.2:last            statements nat.2, nat.3, ... and their descendents\n"

name_syntax2 =
"Names for statements with given properties:\n" ||
"deduction-rules       passive                 proper-ancestors(<names>)\n" ||
"formulas              immune                  proper-descendants(<names>) \n" ||
"induction-rules       nonimmune               contains-operator(<operator>)\n" ||
"operator-theories     ancestor-immune         contains-variable(<variable>)\n" ||
"rewrite-rules         ancestors(<names>)\n" ||
"active                descendants(<names>)\n"

name_syntax3 =
"Operators on sets of names:\n" ||
"<names1>, <names2>     union\n" ||
"<names1> / <names2>    intersection\n" ||
"<names1> ~~ <names2>    difference\n" ||
"eval(<names>)          names of all current facts matching <names>\n" ||
"\n" ||
"Defined classes of names:\n" ||
"$<class>               replaced by definition of $<class> when evaluated\n" ||
"copy($<class>)         replaced by current definition of $<class>\n"

name_syntax = name_syntax1 || "\n" || name_syntax2 || "\n" || name_syntax3

op_poly_syntax =
"Sample polynomial interpretations.\n" ||
"register polynomial c 2\n" ||
"register polynomial __\\U__ x + y + 5\n" ||
"register polynomails __**_ 2*x^2*y, 2*x + y + 2"

opdec_syntax =
"Sample operator declarations:\n" ||
"declare operators\n" ||
"  0, 1:                           -> Int\n"  ||
"  s, +__, -__:           Int      -> Int\n"  ||
"  __+__, __-__, __*__:   Int, Int -> Int\n"  ||
"  {}:                             -> Set\n"  ||
"  {__}:                  Int      -> Set\n"  ||
"  __\\U__, __\\I__, __~~__: Set, Set -> Set\n"  ||
"  __\\subseteq__:         Set, Set -> Bool\n" ||
"  .."

operator_syntax1 = 
"Sample unqualified operators:     Sample qualified operators:\n" ||
"Nullary:  c                       c:                             -> Int\n" ||
"Unary:    succ                    succ:      Int                 -> Int\n" ||
"          -, -__                  -__:       Int                 -> Int\n" ||
"          -, __-                  __-:       Int                 -> Int\n" ||
"          {__}                    {__}:      Int                 -> Set$Int"
operator_syntax2 = 
"Binary:   ~~, __~~__                __~~__:     Set, Set            -> Set\n" ||
"          __[__]                  __[__]:    Array$Int,Nat       -> Int\n" ||
"          f                       f:         Int, Int            -> Int\n" ||
"Ternary:  f                       f:         Int, Int, Int       -> Int\n" ||
"          __[__,__]               __[__,__]: Array$Int, Nat, Nat -> Int"

operator_syntax = operator_syntax1 || "\n" || operator_syntax2

pm_syntax = 
"Proof methods:\n" ||
"/\\-method                    for conjectures of the form t1 /\\ ... /\\ tn\n" ||
"=>-method                    for conjectures of the form t1 => t2\n" ||
"<=>-method                   for conjectures of the form t1 <=> t2\n" ||
"cases t1, ..., tn            by division into cases t1, ..., tn\n" ||
"contradiction                by contradiction\n" ||
"default                      by method in last `set proof-methods' command\n" ||
"explicit-commands            by method in next `resume' command\n" ||
"generalizing x from t        for conjectures containing `\\A x'\n" ||
"if-method                    for conjectures of the form \n" ||
"                                 (if t1 then t2 else t3) = t4\n" ||
"induction on x using <names> by induction using named induction rule\n" ||
"normalization                by reduction to normal form\n" ||
"specializing x to t          for conjectures containing `\\E x'"

prove_syntax =
"Legal prove commands:                        Examples:\n" ||
"prove ac <operator>                          prove ac +\n" ||
"prove commutative <operator>                 prove commutative relPrime\n" ||
"prove <deduction-rule>                       prove when x + y = x yield y = 0\n" ||
"prove <formula> [by <proof-method>]          prove 0 + x = x by induction\n" ||
"prove sort <sort> generated by <operators>   prove sort Nat generated by 0, s\n" ||
"prove sort <sort> partitioned by <operators> prove sort Set partitioned by \\in\n"

sort_syntax = 
"Sample sort declarations:\n" ||
"declare sort Nat\n" ||
"declare sorts Int, Set$Int"

specialize_syntax =
"Sample existential quantifier introduction commands:\n" ||
"prove \\E x \\A y (x <= y) by specializing x to 0\n" ||
"prove \\A x \\E y (x < y) by specializing y to s(x)"

term_syntax =
"Sample terms:\n" ||
"x                   % a variable or constant of an unambigiuous sort\n" ||
"x1:S                % a variable or constant of sort S\n" ||
"f(succ(x))          % functional notation for operators\n" ||
"-x, x!              % prefix and postfix operators\n" ||
"x < ((x*y) + x)     % infix operators (parentheses required)\n" ||
"{}, {x}, a[3]       % bracketing notations\n" ||
"f(m:int):int        % fully qualified subterms"

vardec_syntax =
"Sample variable declarations:\n" ||
"declare variable i: Int\n" ||
"declare variables j, k: Int, x, y: Set$Int"
