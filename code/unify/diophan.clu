#extend


% The solutions to a linear homogeneous positive diophantine equation form a
% commutative monoid and can therefore be generatated by a finite basis.  This
% procedure finds such a basis of non-trivial solutions for a given linear
% homogeneous positive diophantine equation.  A basis is a set of integral
% solutions to the equations which can then be linearly combined to form all
% possible solutions.  The basis that is returned is minimal (i.e. there are no
% extraneous elements) as well as complete and is therefore unique.  The
% procedure is a fairly straightforward implementation of the algorithm
% described by Gerard Huet [Information Processing Letters, Vol 2, No 3, April
% 1978, p. 144-147]

% Although the computation seems overly complex for the size of equations which
% will commonly be used (i.e., a more brute-force approach would probably find
% a basis in less time) we use this one because it is gauranteed to provide a
% minimal basis.  An unnecessary element in the basis would not result in an
% incorrect answer for the AC-unification algorithm as a whole, but could cause
% greater loss of time later than is spent here to assure minimality.  This is
% because each element in the basis is combined with all other elements to for
% the complete set of solutions, and the increased number of critical pairs
% being generated by unification for lp to reduce would probably slow down
% noticeably.


diophan_basis = proc [t: type] (eqn: plh_eqn[t]) returns (solution[t])
			signals(trivial, unsolvable)
	    where t in equal_type
    t_arr = array[t]
    t_gen = generator[t] 		% solution generator
    t_soln = solution[t]
    t_seq = sequence[t]
    t_vec = vector[t]

    plh_eqn[t]$cancel_common(eqn)
    if plh_eqn[t]$empty(eqn) 
       then signal trivial
       else
	    lcoeffs: int_seq, lvars: t_seq := plh_eqn[t]$get_left(eqn)
	    rcoeffs: int_seq, rvars: t_seq := plh_eqn[t]$get_right(eqn)
	    if int_seq$empty(lcoeffs) 
		 cor int_seq$empty(rcoeffs)
	       then signal unsolvable
	       end
       end
    % Calculate the array of maximum possible values for X and Y.
    A, B: int_seq
    X, Y: t_seq
    A, X := plh_eqn[t]$get_left(eqn)
    B, Y := plh_eqn[t]$get_right(eqn)
    vars: t_vec := t_vec$seq2v(X || Y)

    % Generate each trial solution in lexicographic order and see if it is a
    % solution.
    dio: pos_diophantine := pos_diophantine$create(A, B)
    soln: t_soln := t_soln$create(vars)
    zero_vec: int_seq := int_seq$fill(t_seq$size(X) + t_seq$size(Y), 0)
    result: t_gen := t_gen$create(soln.vars, zero_vec)
    for soln_seq: int_seq in pos_diophantine$bounded_X_Y(dio) do
	if soln_seq = zero_vec then continue end
	result := t_gen$replace_vals(result, soln_seq)
	if plh_eqn[t]$is_soln(eqn, result) 
	   then
		is_minimal: bool := true
		for gen: t_gen in t_soln$generators(soln) do
		    if ~(result < gen) then is_minimal := false end
		    end
	        if is_minimal then t_soln$add_gen(soln, result) end
	   end
	   except when empty: t_soln$add_gen(soln, result) end
	end

    % Add the special solutions which are greater than those generated as 
    % possible solutions.
    for S_ij_X, S_ij_Y: int_seq in pos_diophantine$special_solutions(dio) do
	t_soln$add_gen(soln, t_gen$create(vars, S_ij_X || S_ij_Y))
	end
    return(soln)
    end diophan_basis


pos_diophantine = cluster is create, D_matrix, E_matrix, E_jk, 
			     bounded_X_Y, max_y, special_solutions

    rep = record[A_coeffs: int_seq,
		 B_coeffs: int_seq,
		 D_mat: working_mat,
		 E_mat: working_mat]

    working_mat = variant[empty: null, full: int_mat]


    create = proc (A, B: int_seq) returns (cvt) 
	       signals (non_positive, bad_coeffs)
	if int_seq$empty(A) then signal bad_coeffs end
	if int_seq$empty(B) then signal bad_coeffs end	
	for a_i: int in int_seq$elements(A) do
	    if a_i < 1 then signal non_positive end
	    end
	for b_i: int in int_seq$elements(B) do
	    if b_i < 1 then signal non_positive end
	    end
	return(rep${A_coeffs: A, 
		    B_coeffs: B, 
		    D_mat: working_mat$make_empty(nil),
		    E_mat: working_mat$make_empty(nil)})
	end create

    D_matrix = proc (dio: cvt) returns (int_mat)
	tagcase dio.D_mat
	   tag full(D: int_mat): return(D)
	   tag empty:
	       mat: int_mat := int_mat$fill(int_seq$size(dio.A_coeffs), 
					    int_seq$size(dio.B_coeffs), 0)
	       for i: int in int$from_to(1, int_seq$size(dio.A_coeffs)) do
		   for j: int in int$from_to(1, int_seq$size(dio.B_coeffs)) do
		       mat[i][j] := lcm(dio.A_coeffs[i], 
					dio.B_coeffs[j])/dio.A_coeffs[i]
		       end
		   end
	       working_mat$change_full(dio.D_mat, mat)
	       return(mat)
	   end
	end D_matrix

    E_matrix = proc (dio: cvt) returns (int_mat)
	tagcase dio.E_mat
	   tag full(E: int_mat): return(E)
	   tag empty:
	       mat: int_mat := int_mat$fill(int_seq$size(dio.A_coeffs), 
					    int_seq$size(dio.B_coeffs), 0)
	       for i: int in int$from_to(1, int_seq$size(dio.A_coeffs)) do
		   for j: int in int$from_to(1, int_seq$size(dio.B_coeffs)) do
		       mat[i][j] := lcm(dio.A_coeffs[i], 
					dio.B_coeffs[j])/dio.B_coeffs[j]
		       end
		   end
	       working_mat$change_full(dio.E_mat, mat)
	       return(mat)
	   end
	end E_matrix


    % signals bounds if X is larger than the number of coefficients in dio.A or
    % if j is out of the range of dio.B_coeffs.
    E_jk = proc (dio: cvt, X: int_arr, j: int) returns (int_arr) 
	     signals(bounds)
	D: int_mat := D_matrix(up(dio))
	E: int_mat := E_matrix(up(dio))
	result: int_arr := int_arr$new()
	k: int := int_arr$size(X)		% notation from paper
	for i: int in int$from_to(1, k) do
	    if X[i] >= D[i][j]
	       then
		    int_arr$addh(result, E[i][j] - 1)
	       end
	    end resignal bounds
	return(result)
	end E_jk


    bounded_X_Y = iter (dio: cvt) yields (int_seq)
	% get X[i]'s
	max_b: int := maximum(dio.B_coeffs)
	high: int := int_seq$size(dio.A_coeffs)
	X: int_arr := int_arr$fill(1, high, 0)
	just_changed: bool := false
	i: int := high
	while true do
	    while X[i] > max_b cor 
		  (mult_sa(dio.A_coeffs, X) >
		   mult_sa(dio.B_coeffs, max_y(up(dio), X))) do
		i := i - 1
		X[i] := X[i] + 1
		zero_sub_arr(X, i + 1)
		end except when bounds: return end
	    i := high
	    for Y: int_arr in bounded_Y(up(dio), X, 
					mult_sa(dio.A_coeffs, X)) do
		yield(int_seq$a2s(X) || int_seq$a2s(Y))
		end
	    X[high] := X[high] + 1
	    end
	end bounded_X_Y


    bounded_Y = iter (dio: cvt, X: int_arr, sum_ax: int) yields (int_arr)
	high: int := int_seq$size(dio.B_coeffs)
	for Y: int_arr in lexi_arr(max_y(up(dio), X)) do
	    if mult_sa(dio.B_coeffs, Y) <= sum_ax 
	       then yield(Y)
	       end
	    end
	end bounded_Y


    max_y = proc (dio: cvt, X: int_arr) returns (int_arr)
	      signals (bounds)
	result: int_arr := int_arr$new()
	for j: int in int$from_to(1, int_seq$size(dio.B_coeffs)) do
	    an_E_jk: int_arr := E_jk(up(dio), X, j)
	       resignal bounds
	    if int_arr$empty(an_E_jk)
	       then int_arr$addh(result, maximum(dio.A_coeffs))
	       else int_arr$addh(result, minimum(int_seq$a2s(an_E_jk)))
	       end
	    end
	return(result)
	end max_y


    special_solutions = iter (dio: cvt) yields (int_seq, int_seq)
	D: int_mat := D_matrix(up(dio))
	E: int_mat := E_matrix(up(dio))
	result_X: int_arr := int_arr$fill(1, int_seq$size(dio.A_coeffs), 0)
	result_Y: int_arr := int_arr$fill(1, int_seq$size(dio.B_coeffs), 0)
	for i: int in int$from_to(1, int_seq$size(dio.A_coeffs)) do
	    for j: int in int$from_to(1, int_seq$size(dio.B_coeffs)) do
		result_X[i] := D[i][j]
		result_Y[j] := E[i][j]
		yield(int_seq$a2s(result_X), int_seq$a2s(result_Y))
		result_X[i] := 0
		result_Y[j] := 0
		end
	    end
	end special_solutions

    end pos_diophantine

