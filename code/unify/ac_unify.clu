#extend

% Behavior:
% A procedure to unify the top level of two terms whose root function symbols
% have the equational theory made up of the associative and commutative axioms.
% (This procedure unifies as if the two roots are AC; it does not check to see
% that they are.)  If the top two operators are not the same or there is no
% unifier of the two terms, then "not_unifiable" is signalled.  The two basic
% reasons that two terms cannot be unified are because the operator symbols
% clash (e.g., "x + y" unified with "x * y") or because a unifying substitution
% would cause a cycle to be formed (e.g., "x + y" unified with "x" would
% require that "x" be assigned a term containing itself).

% If new variables are required to describe the unifiers, they are generated by
% "var_gen$next".  This procedure ensures that new variables are distinct from
% each other (since a clash in variable names would change the value of the
% unifiers).  It also ensures that new variables are distinct from variables in
% the input terms "t1" and "t2"; it does this by generating "internal"
% variables.

% Implementation:
% "t1" and "t2" are unified by creating a linear homogeneous equation and
% solving it as a positive diophantine equation, i.e., for integral solutions
% only.  This is what Stickel calls the variable-only case.  From this we get a
% mapping from terms to terms, which is not a legitimate substitution unless
% each <domain, range> pair in the mapping can also be unified.  The domain is
% made up of all the "proper" arguments of "t1" and "t2".  (The term "proper"
% argument is defined in Fage 83, and has the same meaning as arguments of a
% "flattened" term as defined by Stickel.  Note that if we had only variable
% subterms in "t1" and "t2", the mapping is essentially from variables to 
% terms, and would be a valid substitution, so the recursive calls to unify 
% only serve to convert the type of the answer.

% The exception "not_unifiable" is raised under the following conditions: 1)
% the top function symbols of "t1" and "t2", called roots, clash.  2) The
% diophantine equation has no solution.  3) The equation can be solved, but
% none of the resulting mappings lead to a valid substitution.  Only one of the
% solutions has to work for there to be a unifier; this is the reason for the
% trapping and flagging of exceptions.  This property also makes it difficult
% to distinguish between clash and cycle unification failure, since some of the
% potential solutions may ultimately lead to clash while others lead to a
% cycle.  We, therefore, refrain from trying to distinguish between cycles and
% clashes even where it is possible.

% MODIFIES AT MOST: "vg"

ac_unify = iter (t1, t2: term, osys: op_system, stab: symtab, vg: var_gen) 
	     yields (substitution) signals (not_unifiable)

    if t1.root ~= t2.root then signal not_unifiable end
       except when wrong_tag: signal not_unifiable end
    ts: ac_term_space := ac_term_space$create(t1.root)
    eqn: plh_eqn[term] := 
	plh_eqn[term]$create(ac_term_space$term2poly(ts, t1),
	    		     ac_term_space$term2poly(ts, t2))
    found_one: bool := false
    for soln: term_soln in constrained_solns(eqn) do
	tbs: tb_seq := ac_term_space$soln2seq(ts, soln, vg)
	for sigma: substitution in unify_seq(tbs, osys, stab, vg) do
	    found_one := true
	    yield(sigma)
	    end except when not_unifiable: end
	end 
       except when unsolvable: signal not_unifiable
	      when trivial: yield(substitution$new())
			    found_one := true
	      end
    if ~found_one then signal not_unifiable end
    end ac_unify


% Yields a complete set of unifiers of "tbs", a sequence of pairs of terms.  (A
% unifier of a sequence of pairs of terms is a substitution that unifies each
% pair.)  Signals "not_unifiable" if no unifiers exist.  MODIFIES AT MOST: "vg"

unify_seq = iter (tbs: tb_seq, osys: op_system, stab: symtab, vg: var_gen) 
	      yields (substitution) signals (not_unifiable)
    yielded: bool := false
    for s: substitution 
	  in unify_seq_work(tbs, osys, substitution$[], stab, vg) do
	yield(s)
	yielded := true
	end
    if ~yielded then signal not_unifiable end
    end unify_seq


% First applies the substitution "s" to the sequence of pairs of terms "tbs".
% Then yields a complete set of unifiers of the resulting sequence of term
% pairs, composed with "s".  (A unifier of a sequence of pairs of terms is a
% substitution that unifies each pair.)  MODIFIES AT MOST: "vg"

unify_seq_work = iter (tbs: tb_seq, osys: op_system, s: substitution, 
		       stab: symtab, vg: var_gen) yields (substitution)

    b: term_bind := tb_seq$bottom(tbs)
    t1: term := substitution$apply(s, b.domain, stab)
    t2: term := substitution$apply(s, b.range, stab)

    tbs := tb_seq$reml(tbs)
    if tb_seq$empty(tbs)
       then for mu: substitution in general_unify(t1, t2, osys, stab, vg) do
		yield(substitution$compose(mu, s, stab))
		end
       else for mu: substitution in general_unify(t1, t2, osys, stab, vg) do
		rho: substitution := substitution$compose(mu, s, stab)
		for sig: substitution
		      in unify_seq_work(tbs, osys, rho, stab, vg) do
		    yield(sig)
		    end
		end
       end except when not_unifiable: end

    end unify_seq_work

