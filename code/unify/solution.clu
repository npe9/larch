% $Header: solution.clu,v 2.1 91/03/26 22:47:42 mtv Exp $
% $Log:	solution.clu,v $
% Revision 2.1  91/03/26  22:47:42  mtv
% substituted ent_arr$predict for ent_arr$new in chart$fetch
% 
% Revision 2.0  91/02/28  19:53:21  mtv
% LP 2.0 release
% 

#extend


% A solution to a diophantine equation is, in its simplest form, an assignment
% (or mapping) of variables to integer values.  For the purpose of
% AC-unification, we are interested in the complete set of positive solutions
% to a homogeneous linear diophantine equation with only positive coefficients.
% Equations of this form have either one solution (the trivial solution of all
% zeros) or an infinite number, since given one non-trivial solution we can
% immediately find another by multiplying all values by an integer constant.
% Although the complete set of solutions is usually infinite, it forms a
% commutative monoid and may therefore be generated by a finite basis.  There
% is a unique minimal basis (which we will refer to simply as the basis) whose
% elements are all minimal solutions to the equation.  A solution, s1, is
% minimal iff there is not another solution, s2, for which all values in s2 are
% less than the corresponding value in s1. Each solution can be thought of as a
% linear combination of the basis elements.

% Because we cannot assume the existance of an identity element, we are
% actually looking for a restricted set of elements of the monoid, namely,
% those that do not contain the identity element for integers, 0.  A set of
% elements of the basis in which all variables are mapped to a non-zero value
% in at least one of the elements will be called a non-zero elementary
% solution.  Note that this set can also be represented as a linear combination
% of the complete basis in which those elements that occur in the set are
% multiplied by 1, and those that are not, are multiplied by 0.  The solutions
% of interest are those solutions which are positive linear combinations of the
% basis elements in each of the non-zero solutions.

% This routine generates and yields the complete set of elementary nonzero
% solutions to eqn which meet the following constraints.  Each solution in this
% set is yielded exactly once.


%    1) Only positive integer solutions are calculated (this corresponds to 
%	positive diophantine equations.
%    2) Each solution, s, is a combination of exactly one occurance of some 
% 	of the elements of the basis.
%    3) All variables map to a non-zero value in at least one basis
% 	element.
%    4) All nonvariable terms, t, in the domain, or 'variable' set map
%	to a nonzero element in only one of the basis elements in a
%	solution.  Furthermore, the value of t in that basis is 1.

% The last constraint in the above list is made for the sake of efficiency.  We
% already know at this point in the algorithm that a nonvariable in the
% equation domain will be unifiable only with a variable in the range of
% solutions (because any nonvariable terms formed from elements in the range
% must have the wrong operator).

% This procedure could be replaced by an implemenation of Hullot's algorithm
% for partitioning within constraints.  This would probably improve the
% efficiency of the entire unification system significantly.

constrained_solns = iter (eqn: plh_eqn[term]) yields (term_soln)
		      signals (unsolvable, trivial)
    basis: term_soln := diophan_basis[term](eqn)
       resignal trivial, unsolvable
    found_one: bool := false
    for tgs: tgen_set in partition[term_gen, null, null]
			     (term_soln$s2set(basis), no_zeros, nil,
			      no_clashes, nil) do
	yield(term_soln$set2s(tgs)) 
		except when empty: end
	end
    end constrained_solns


no_zeros = proc (ts: tgen_set, dummy: null) returns (bool)
    soln: term_soln := term_soln$set2s(ts)
	except when empty: return(false) end
    for bind: ti_bind in ti_assn$bindings(term_soln$assign_total(soln)) do
	if bind.range = 0 then return(false) end
	end
    return(true)
    end no_zeros


no_clashes = proc (ts: tgen_set, dummy: null) returns (bool)
    one: infinite_int := infinite_int$make_finite(1)
    infinity: infinite_int := infinite_int$make_pos_infin()

    assn: ti_assn := term_soln$assign_total(term_soln$set2s(ts))
	except when empty: return(true) end
    vars: term_seq, vals: int_seq := ti_assn$assn2seqs(assn)
    actuals: infin_arr := infin_arr$[]
    for i: int in int_seq$elements(vals) do
	infin_arr$addh(actuals, infinite_int$make_finite(i))
	end
    constraints: infin_arr := infin_arr$[]
    for t: term in term_seq$elements(vars) do
	if term$is_funct(t) % FIX for quantifiers
	   then infin_arr$addh(constraints, one)
	   else infin_arr$addh(constraints, infinity)
	   end
	end
    answer: bool 
    for i: int in infin_arr$indexes(constraints) do
	if constraints[i] < actuals[i] then return(false) end
	end
    return(true)
    end no_clashes


infinite_int = cluster is make_finite, make_pos_infin, make_neg_infin,
			  is_finite, value_finite, lt, equal, similar, copy
			
    rep = oneof[finite: int,
		pos_infinite: null, 
		neg_infinite: null]

    make_finite = proc (i: int) returns (cvt)
	return(rep$make_finite(i))
	end make_finite

    make_pos_infin = proc () returns (cvt)
	return(rep$make_pos_infinite(nil))
        end make_pos_infin

    make_neg_infin = proc () returns (cvt)
	return(rep$make_neg_infinite(nil))
        end make_neg_infin

    is_finite = proc (ii: cvt) returns (bool)
	return(rep$is_finite(ii))
        end is_finite

    value_finite = proc (ii: cvt) returns (int) signals (infinite)
	tagcase ii
	   tag finite(val: int): return(val)
	   others: signal infinite
	   end
        end value_finite

    lt = proc (ii1, ii2: cvt) returns (bool)
	tagcase ii1
	   tag finite (val1: int):
	       tagcase ii2
		  tag finite (val2: int): return(val1 < val2)
		  tag pos_infinite: return(true)
		  tag neg_infinite: return(false)
		  end
	   tag pos_infinite:
	       return(false)
	   tag neg_infinite:
	       tagcase ii2
		  tag finite: return(true)
		  tag pos_infinite: return(true)
		  tag neg_infinite: return(false)
		  end
	   end
        end lt

    equal = proc (ii1, ii2: cvt) returns (bool)
	return(ii1 = ii2)
        end equal

    similar = proc (ii1, ii2: cvt) returns (bool)
	return(ii1 = ii2)
        end similar

    copy = proc (ii: cvt) returns (cvt)
	return(ii)
        end copy

    end infinite_int


% Might make this more efficient by sharing generators with inputs.
% This is inconsistent because create takes a var_seq, while add_gen takes a
% generator.

solution = cluster [vartype: type] is create, add_gen, empty, generators, 
				      combinations, assigns, assign_total, 
				      value, gen_size, get_vars, s2set, set2s, 
				      unparse, equal, similar, copy, copy1
	    where vartype in equal_type

    rep = record[vars: var_vec,
		 chart: vi_chart]

    vi_chart = chart[vartype, int]
    var_vec = vector[vartype]

    var_int_assn = assignment[vartype, int]
    vis_assn = assignment[vartype, int_seq]
    vis_bind = binding[vartype, int_seq]

    var_seq = sequence[vartype]
    var_soln = solution[vartype]

    var_gen = generator[vartype]
    gen_set = set[var_gen]

    % Rep Invariant: for all bases, b = abstract(r)
    % 	1) for all generators, s1, s2 in r, environment(s1) = environment(s2)
    

    % Create a solution whose domain is the collection of variables vc.  Signal
    % empty if vc is empty.

    create = proc (vs: var_vec) returns (cvt) signals (empty)
	return(rep${vars: vs,
		    chart: vi_chart$create(var_vec$v2seq(vs))})
	end create


    % Add a generator, gen, to the solution, soln.  Note that soln is not
    % tested to see if gen already exists.  A copy1 is made of gen to prevent
    % "exposing the rep", i.e., further mutations of gen will not affect the
    % generator that is in soln.  (This may be overly protective, since one
    % would probably not mutate a generator once it has been added to the
    % solution, and there is a slight possibility that they would want mutation
    % reflected in the solution.)

    add_gen = proc (soln: cvt, gen: var_gen) signals (incompatible)
	vars: var_vec := gen.vars
	vals: int_seq := gen.vals
	if soln.vars ~= vars then signal incompatible end
	vi_chart$add_row(soln.chart, vals)
	end add_gen

    % Return true iff there are no generators in the solution.
    empty = proc (soln: cvt) returns (bool)
	return(vi_chart$empty(soln.chart))
	end empty


    % Yield each generator in the solution exactly once.

    generators = iter (soln: cvt) yields (var_gen)
	result: var_gen := var_gen$create(soln.vars, 
					  int_seq$fill(var_vec$size(soln.vars),
						       0))
	for gen_value: int_seq in 
	    si_coll$elements(vi_chart$rows(soln.chart)) do
	    yield (var_gen$replace_vals(result, gen_value))
	    end
	end generators

    % Yield all the solutions which are combinations of the generators in soln.
    % This is where the fact that solutions to the kinds of equation we are
    % working with form a commutative monoid comes into play.  If we consider a
    % particular monoid (i.e., solution) to be defined by the generators g1,
    % g2, g3 then g1, g2, g1 * g2, g1 * g3, g2 * g3, and g1 * (g2 * g3) are all
    % solutions.

    combinations = iter (soln: cvt) yields (cvt) signals (none)
	sc: si_coll := vi_chart$rows(soln.chart)
	if si_coll$empty(sc) then signal none end
	result: var_gen := var_gen$create(soln.vars, 
					  int_seq$fill(var_vec$size(soln.vars),
						       0))
	for c_sub: si_coll in si_coll$subsets(sc) do
	    sub_tab: vi_chart := vi_chart$create(var_vec$v2seq(soln.vars))
	    for si: int_seq in si_coll$elements(c_sub) do
		add_gen(up(rep${vars: soln.vars, chart: sub_tab}), 
			var_gen$replace_vals(result, si))
		end
	    yield (rep${vars: soln.vars, chart: sub_tab})
	    end 
	end combinations


    % Return the assignment from vartype to integer sequences in the solution.

    assigns = proc (s: cvt) returns (vis_assn)
	a: vis_assn := vis_assn$create(var_vec$v2seq(s.vars))
	for b: vis_bind in vi_chart$columns(s.chart) do
	    vis_assn$assign(a, b.domain, b.range)
	    end
	return(a)
	end assigns


    assign_total = proc (s: cvt) returns (var_int_assn)
	a: var_int_assn := var_int_assn$create(var_vec$v2seq(s.vars))
	for b: vis_bind in vi_chart$columns(s.chart) do
	    total: int := 0
	    for val: int in int_seq$elements(b.range) do
		total := total + val
		end
	    var_int_assn$assign(a, b.domain, total)
	    end
	return(a)
	end assign_total


    % Return the integer value that is assigned to var in the generator, gen.
    % In this procedure we rely on the fact that the sequence of rows
    % (generators) are in the same order as the sequence of columns, containing
    % only the particular element of each row.  We also know that all sequences
    % that are returned from chart start at 1.

    value = proc (soln: cvt, gen: var_gen, var: vartype) returns (int)
	      signals (bad_generator, not_in)
	index: int := 0
	for gen1: var_gen in generators(up(soln)) do
	    index := index + 1
	    if var_gen$similar1(gen1, gen) 
	       then return(soln.chart[var].range[index])
	       end
	    end		
	end value


    % Returns the number of generators that define the solution, soln.  Note:
    % this is the same as the number of add_gen's.

    gen_size = proc (soln: cvt) returns (int)
	return(vi_chart$column_size(soln.chart))
	end gen_size

    % Return the sequence of variables that was used to create the solution
    % "soln".

    get_vars = proc (soln: cvt) returns (var_vec)
	return(soln.vars)
	end get_vars


    s2set = proc (soln: cvt) returns (gen_set)
	result: gen_set := gen_set$[]
	for vg: var_gen in generators(up(soln)) do
	    gen_set$insert(result, vg)
	    end
	return(result)
        end s2set

    set2s = proc (gs: gen_set) returns (cvt) signals (empty, incompatible)
	vg: var_gen := gen_set$any_element(gs)
	   resignal empty
	result: var_soln := create(vg.vars)
	for vg in gen_set$elements(gs) do
	    add_gen(result, vg)
	    end resignal incompatible
	return(down(result))
	end set2s

    unparse = proc (soln: cvt) returns (string)
		where vartype in unparse_type
	return(vi_chart$unparse(soln.chart))
	end unparse


    % Return true iff s1 and s2 are the same object.

    equal = proc (s1, s2: cvt) returns (bool)
	return(s1 = s2)
	end equal


    % Return true if all generators in soln are similar.

    similar = proc (s1, s2: cvt) returns (bool)
		where vartype in similar_type
	return(rep$similar(s1, s2))
	end similar


    % Makes a complete copy of soln.

    copy = proc (soln: cvt) returns (cvt)
		where vartype in copy_type
	return(rep$copy(soln))
	end copy


    % Copy the structure of the solution, without copying all the generators
    % contained in the solution.

    copy1 = proc (soln: cvt) returns (cvt)
	return(rep${vars: soln.vars, 
		    chart: vi_chart$copy1(soln.chart)})
	end copy1

    end solution



chart = cluster [head_t, entry_t: type] is create, add_row, empty, store, 
					   fetch, get_headings, columns, rows, 
					   row_size, column_size, unparse,
					   equal, similar, copy, copy1
	    where head_t in equal_type,
		  entry_t in equal_type

    % Rep Invariant: all rows have the same size as "headings"


    rep = record[headings: head_seq, size: int,
		 grid: grid]

    grid = array[row]
    row = ent_seq
    column = binding[head_t, ent_seq]

    ent_seq = sequence[entry_t]
    ent_arr = array[entry_t]
    head_seq = sequence[head_t]
    row_coll = collection[row]
    row_seq = sequence[row]


    % Creates a chart with headings "hs" and no values, i.e., with
    % row_size(create(hs)) = 0

    create = proc (hs: head_seq) returns (cvt) signals (empty)
	if head_seq$empty(hs) then signal empty end
	return(rep${headings: hs, size: head_seq$size(hs),
		    grid: grid$new()})
	end create


    % Adds a row to the char "t".  Signals "incompatible" if the size of the
    % row does not equal the size of "t.headings".

    add_row = proc (t: cvt, r: row) signals (incompatible)
	if row$size(r) ~= t.size then signal incompatible end
	grid$addh(t.grid, r)
	end add_row

    % Returns true iff there are no rows in the chart.

    empty = proc (t: cvt) returns (bool)
	return(grid$empty(t.grid))
	end empty

    % Replaces "r1" by "r2" in "t".

    store = proc (t: cvt, r1, r2: row) signals (incompatible, not_in)
	if row$size(r2) ~= t.size then signal incompatible end
	is_in: bool := false
	for i: int in grid$indexes(t.grid) do
	    if t.grid[i] = r1 
	       then t.grid[i] := r2
		    is_in := true
	       end
	    end
	if is_in then return else signal not_in end
	end store


    % Finds the column that has "ch" as its heading and returns the sequence of
    % entries from top to bottom.

    fetch = proc (t: cvt, ch: head_t) returns (column) signals (not_in)
	location: int := 0
	for i: int in head_seq$indexes(t.headings) do
	    if t.headings[i] = ch then location := i break end
	    end
	if location = 0 then signal not_in end
	values: ent_arr := ent_arr$predict(1, grid$size(t.grid))
	for es: ent_seq in grid$elements(t.grid) do
	    ent_arr$addh(values, es[location])
	    end
	return(column${domain: ch, range: ent_seq$a2s(values)})
	end fetch


    % Returns heading with which the chart was created.
    % This is actually the same object and not a copy.

    get_headings = proc (t: cvt) returns (head_seq)
	return(t.headings)
	end get_headings


    % Yields each column of the chart exactly once. There is no implicit order
    % on the columns.  Signals "empty" if there are no values in the chart
    % (i.e.  no rows).

    columns = iter (t: cvt) yields (column) signals (empty)
	if grid$empty(t.grid) then signal empty end
	for h: head_t in head_seq$elements(t.headings) do
	    yield(up(t)[h])
	    end
	end columns


    % Returns the set (collections) of rows in "t".

    rows = proc (t: cvt) returns (row_coll)
	return(row_coll$seq2c(row_seq$a2s(t.grid)))
	end rows


    % Returns the size of rows in chart "t".

    row_size = proc (t: cvt) returns (int)
	return(t.size)
	end row_size


    % Returns the size of columns in chart "t".
    column_size = proc (t: cvt) returns (int)
	return(grid$size(t.grid))
	end column_size


    % Write a more general procedure to unparse sequences of anything.

    unparse = proc (t: cvt) returns (string)
		where head_t in unparse_type,
		      entry_t in unparse_type
	s: string := ""
	for elem: head_t in head_seq$elements(t.headings) do
	    e_string: string := head_t$unparse(elem)
	    if string$size(e_string) > elem_length
	       then e_string := string$substr
				    (e_string, 1, elem_length -
						  string$size(unp_suffix)) ||
				unp_suffix
	       else while string$size(e_string) < elem_length do
			e_string := " " || e_string
			end
	       end
	    s := s || "  " || e_string 
	    end
	s := s || next_line
	for r: row in grid$elements(t.grid) do
	    for elem: entry_t in row$elements(r) do
		e_string: string := entry_t$unparse(elem)
		if string$size(e_string) > elem_length
		   then e_string := string$substr
					(e_string, 1, elem_length -
						      string$size(unp_suffix)) ||
				    unp_suffix
		   else while string$size(e_string) < elem_length do
			    e_string := " " || e_string
			    end
		   end
		s := s || "  " || e_string
		end
	    s := s || next_line
	    end
	return(s)
	end unparse

    equal = proc (t1, t2: cvt) returns (bool)
	return(t1 = t2)
	end equal

    similar = proc (t1, t2: cvt) returns (bool)
		where head_t in similar_type, 
		      entry_t in similar_type
	return (rep$similar(t1, t2))
	end similar

    copy = proc (t: cvt) returns (cvt)
		where head_t in copy_type, 
		      entry_t in copy_type
	return(rep$copy(t))
	end copy

    copy1 = proc (t: cvt) returns (cvt)
	return(rep$copy1(t))
	end copy1

    end chart

