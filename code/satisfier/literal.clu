#extend

% A literal is an atomic boolean formula or the negation of an atomic boolean
% formula, where a boolean formula is atomic if its top operator is not one of
% the logical connectives ~, /\, \/, or =>.  Note that a boolean formula is
% atomic if its top operator is <=>, =, or ~=.

% FIX:  Is this correct for ~=?

% The negation "~l" of a literal "l" is the literal
%	"false"		if "l" is "true"
%	"true"		if "l" is "false"
%	"~f"		if "l" is an atomic boolean formula "f"
%	"f"		if "l" is "~f", where "f" is an atomic boolean formula
% The literals "~true", "~false" are identical to the literals "false", "true".

% A literal is "negative" if it is "false" or if it is the negation of an 
% atomic boolean formula.  Otherwise it is "positive".

% FIX: ~=

% Fresh literals are literals whose underlying atomic formula is a
% boolean-valued constant generated by this cluster.


% The representation for a literal also contains optional fields used by the
% "equiv_relation" cluster to maintain an equivalence relation over literals.


literal = cluster is 
	create, term2lit, make_equality, truth, make_fresh, 
	get_args, get_negation, get_root, get_sense, is_constant, is_fresh,
	lit2term, print, equal, reset_counter, _gcd,
	
	% The following procedures are for use by "equiv_relation" to maintain
	% equivalence relation among literals.

	get_in_relation, set_in_relation, get_next_in_class, set_next_in_class,
	get_class_rep, set_class_rep, get_class_size, set_class_size,
	get_count, set_count, same_object


    rep = record[t: term, 
                 sense: bool, 
		 fresh: bool, 
		 negation: maybe_literal,
		 relation: maybe_relation]

    maybe_literal  = maybe_obj[literal]		 
    maybe_relation = maybe_obj[relation_info]
    relation_info  = record[class_rep: literal,
			    class_size: int,
			    count: int,
			    next_in_class: literal]

    % A(r) = (if sense = true then r.t else ~r.t)
    % Representation invariants: 
    %   r.t is an atomic boolean term
    %	if r.t = term_true or r.t = term_false, then r.sense = true
    

    own counter: int := 0

    
    % Returns the literal represented by "t".  Signals "not_literal" if "t"
    % does not represent a literal.
    
    create = proc (t: term) returns (literal) signals (not_literal)
	% Handle boolean equivalences first
	if t.root = op_bool_equals() cor t.root = op_iff() then
	   return(term2lit(t, true))
	   end
	if ~term_is_literal(t) then signal not_literal end
	sense: bool := true
	if t.root = op_not() then 
	   t := t.args[1]
	   if t.root = op_true() then 		t := term_false()
	    elseif t.root = op_false() then 	t := term_true()
	    else            			sense := false
	    end
	   end
	return(term2lit(t, sense))
	end create
    

    % Requires: "t" is an atomic boolean term
    % Returns the literal represented by "t" if "sense" is "true" and by "~t"
    % if "sense" is "false".
    
    term2lit = proc (t: term, sense: bool) returns (cvt)
	return(rep${t: t, sense: sense, fresh: false,
		    negation: maybe_literal$none(),
		    relation: maybe_relation$none()})
	end term2lit
   
    
    % Requires: t1.sort = t2.sort
    % Returns a literal representing the equality "t1 = t2".
    
    make_equality = proc (t1, t2: term) returns (literal)
	return(term2lit(term2(op_eq(t1.sort), t1, t2), true))
	end make_equality
    
    
    % Returns a literal representing "true".
    
    truth = proc () returns (literal)
	return(term2lit(term_true(), true))
	end truth
    
    
    % Returns fresh positive literal.
    
    make_fresh = proc () returns (cvt)
	counter := counter + 1		  
	id: identifier := identifier$make_simple("lit" || int$unparse(counter))
	t: term := term0(operator${id: id, sig: sig_bool0()})
	l: rep := down(term2lit(t, true))
	l.fresh := true
	return(l)
	end make_fresh

    
    % Returns the arguments of "l".
    
    get_args = proc (l: cvt) returns (term_seq)
	return(l.t.args)
	end get_args

    
    % Returns "~l".
    
    get_negation = proc (l: cvt) returns (literal)
	return(l.negation.value)
	   except when wrong_tag: end
	neg: literal
        if l.t = term_true() then neg := term2lit(term_false(), true)
	 elseif l.t = term_false() then neg := truth()
	 else neg := up(rep${t: l.t, sense: ~l.sense, fresh: l.fresh,
			     negation: maybe_literal$none(),
			     relation: maybe_relation$none()})
	 end
	l.negation := maybe_literal$make(neg)
	down(neg).negation := maybe_literal$make(up(l))
	return(neg)
	end get_negation

    
    % Returns the top-level operator of "l".

    get_root = proc (l: cvt) returns (operator)
	return(l.t.root)
	end get_root

    
    % Returns "true" iff "l" is an atomic boolean formula.
    
    get_sense = proc (l: cvt) returns (bool)
	return(l.sense)
	end get_sense

    
    % Returns true if the underlying atomic boolean formula of "l" is a
    % constant.
    
    is_constant = proc (l: cvt) returns (bool)
	return(l.t.root.arity = 0)
	end is_constant

    
    % Returns true iff "l" is fresh.
    
    is_fresh = proc (l: cvt) returns (bool)
	return(l.fresh)
	end is_fresh

    
    % Returns a formula equivalent to "l".
    
    lit2term = proc (l: cvt) returns (term)
	if l.sense then return(l.t) end
	return(term1(op_not(), l.t))
	end lit2term
    

    % Prints "l" on "pr"
    
    print = proc (pr: printer, l: cvt, stab: symtab)
	term$print(pr, lit2term(up(l)), stab)
	end print
    
    
    % Dumps "l" on the standard output (for debugging).
    
    dump = proc (l: cvt)
	pr: printer := tracer$get_printer()
	print(pr, up(l), tracer$get_symtab())
	printer$newline(pr)
	end dump
    
    
    % Returns true iff "l1" and "l2" are equivalent boolean formulas.
    
    equal = proc (l1, l2: cvt) returns (bool)
%	if down(l1.relation.value.class_rep) 
%	     = down(l2.relation.value.class_rep) then 
%	   return(true)
%	   end except when wrong_tag: end
	if l1.sense ~= l2.sense then return(false) end
	return(l1.t.enode.root = l2.t.enode.root)
	   except when none: return(l1.t = l2.t) end
	end equal

    
    % Resets the fresh literal generator.
    
    reset_counter = proc ()
	counter := 1
	end reset_counter
    
    
    % Necessary for "gc_dump".

    _gcd = proc (x: cvt, tab: gcd_tab) returns (int)
	return(rep$_gcd(x, tab))
	end _gcd


    % The following procedures are for use by "equiv_relation" to maintain
    % equivalence relation among literals.
    

    % Returns "true" if "l" is in an equivalence relation.
    
    get_in_relation = proc (l: cvt) returns (bool)
	return(maybe_relation$exists(l.relation))
	end get_in_relation
    

    % Requires: b  => l is not in any equivalence relation
    % Ensures:  b  => l is equivalent only to itself
    %		~b => l is not in any equivalence relation
    
    set_in_relation = proc (l: cvt, b: bool)
	if b
	   then if maybe_relation$exists(l.relation) then 
		   fail("literal$set_in_relation")
		   end

	        ri: relation_info := relation_info${class_rep: up(l),
						    class_size: 1,
						    count: 0,
						    next_in_class: up(l)}
		l.relation := maybe_relation$make(ri)
	   else l.relation := maybe_relation$none()
	   end
	end set_in_relation
    

    % Requires: "l" is in an equivalence relation
    % Returns the next literal in the equivalence class of "l".  Returns "l"
    % itself if no other literals are equivalent to "l".

    get_next_in_class = proc (l: cvt) returns (literal)
	return(l.relation.value.next_in_class)
	   except when wrong_tag: fail("literal$get_next_in_class") end
	end get_next_in_class
    

    % Requires: "l1" and "l2" are in the same equivalence relation
    % Sets the next literal equivalent to "l1" to be "l2".
    
    set_next_in_class = proc (l1: cvt, l2: literal)
	l1.relation.value.next_in_class := l2
	   except when wrong_tag: fail("literal$set_next_in_class") end
	end set_next_in_class
    
    
    % Requires: "l" is in an equivalence relation
    % Returns the representative of the equivalence class of "l".
    
    get_class_rep = proc (l: cvt) returns (literal)
	return(l.relation.value.class_rep)
	   except when wrong_tag: fail("literal$get_class_rep") end
	end get_class_rep
    
    
    % Requires: "l1" and "l2" are equivalent
    % Makes "l2" the representative of the equivalence class of "l1".
    
    set_class_rep = proc (l1: cvt, l2: literal)
	l1.relation.value.class_rep := l2
	   except when wrong_tag: fail("literal$set_class_rep") end
	end set_class_rep
    
    
    % Requires: "l" is in an equivalence relation
    % Returns the number of elements in the equivalence class of "l".
    
    get_class_size = proc (l: cvt) returns (int)
	return(l.relation.value.class_size)
	   except when wrong_tag: fail("literal$get_class_size") end
	end get_class_size
    
    
    % Requires: "l" is in an equivalence relation
    % Sets the size of the equivalence class of "l".
    
    set_class_size = proc (l: cvt, n: int)
	l.relation.value.class_size := n
	   except when wrong_tag: fail("literal$set_class_size") end
	end set_class_size


    % Requires: "l" is in an equivalence relation
    % Returns the "count" associated with "l".
    
    get_count = proc (l: cvt) returns (int)
	return(l.relation.value.count)
	   except when wrong_tag: fail("literal$get_count") end
	end get_count
    
    
    % Requires: "l" is in an equivalence relation
    % Sets the "count" associated with "l".
    
    set_count = proc (l: cvt, n: int)
	l.relation.value.count := n
	   except when wrong_tag: fail("literal$set_count") end
	end set_count


    % Returns "true" if "l1" and "l2" are the same object.  Used to distinguish
    % between literals in the same equivalence class.
    
    same_object = proc (l1, l2: cvt) returns (bool)
	return(l1 = l2)
	end same_object
    
    end literal
