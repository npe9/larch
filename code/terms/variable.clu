#extend

% A "variable" denotes an arbitrary element of some sort.

% Variables are essentially immutable.  However, the "symtab" cluster can
% assign a positive key to a variable.  Once known, keys cannot change.  This
% cluster uses keys to optimize checks for variable equality.


variable = cluster is create, get_id, get_key, set_key, 
    		      get_sort, make_internal, is_internal, 
    		      get_alias, is_alias, make_constant,
		      different, read, print, unparse,
		      lt, le, gt, ge, equal, similar, copy, _gcd,
		      decode, encode, set_decode_all, set_encode_all

    % To optimize variable-renaming operations invoked during matching
    % (operator$v2c, operator$c2v) and overlapping (variable$get_alias), most
    % variables come in triples: the variable itself, a conversion to a 0-ary
    % operator (for matching), and an alias as a distinct variable (for
    % overlapping).  Internal variables generated by the "make_internal"
    % operation, which are used in unification, come without the renamings.
    % Internal variables have odd negative keys.  Alias variables have even
    % negative keys.
    
    rep = record[aliases: alias_type, 	% renamings for variable
		 id: identifier,	% identifier for variable
		 key: int,		% unique key for variable (or 0)
		 sort: sort,		% sort of variable
    		 str: string]	        % unique string representation

    alias_type = oneof[exists: alias_info, none: null]
    no_aliases = alias_type$make_none(nil)
    alias_info = struct[alias: variable, constant: operator, is_alias: bool]
    
    
    own decode_all: bool := true
    own encode_all: bool := true
    own decode_map: var_map := var_map$new(1)

    % Returns a variable with identifier "a.id" and sort "a.sort".
    
    create = proc (a: args) returns (cvt)
	args = struct[id: identifier, sort: sort]
	% Create rep for variable
	v: rep := rep${aliases: alias_type$make_none(nil), 
		       id: a.id, 
		       key: 0,
		       sort: a.sort, 
		       str: identifier$id2s(a.id) || ":" ||
		            sort$unparse(a.sort)}
	% Create alias for variable
	aid: identifier := identifier$make_variable_alias(a.id)
	v1: rep := rep${aliases: alias_type$make_none(nil),
			id: aid, 
			key: 0, 
			sort: a.sort,
		        str: identifier$id2s(aid) || ":" ||
			     sort$unparse(a.sort)}
	% Install alias information in variable
	ai: alias_info := alias_info${alias: up(v1), 
				      constant: operator$v2c(up(v)),
				      is_alias: false}
	v.aliases := alias_type$make_exists(ai)
	% Install alias information in alias for variable
	ai1: alias_info := alias_info${alias: up(v), 
				       constant: operator$v2c(up(v1)),
				       is_alias: true}
        v1.aliases := alias_type$make_exists(ai1)
        return(v)
	end create

    
    % Returns the identifier of "v".

    get_id = proc (v: cvt) returns (identifier)
	return(v.id)
	end get_id
    
    
    % Returns the key assigned to "v".  Returns "0" if no key has been 
    % assigned.
    
    get_key = proc (v: cvt) returns (int)
	return(v.key)
	end get_key
    
    
    % Assigns the key "k" to "v".  Assumes "v.key = 0" or "v.key = k", that "k
    % > 0", and that "v" is not an alias or an internal variable.
    
    set_key = proc (v: cvt, k: int)
	if v.key = k then return end
	ai: alias_info := alias_type$value_exists(v.aliases)
	   except when wrong_tag: fail("variable$set_key") end
	if v.key ~= 0 cor k <= 0 cor ai.is_alias then 
	   fail("variable$set_key")
	   end
	v.key := k
	down(ai.alias).key := -2*k
	ai.constant.key := -k
	end set_key
	
    
    % Returns the sort of "v".

    get_sort = proc (v: cvt) returns (sort)
	return(v.sort)
	end get_sort
    
    
    % Returns the "i"th internal variable for sort "so".
    
    make_internal = proc (i: int, so: sort) returns (cvt)
	id: identifier := identifier$make_internal_variable(i)
	return(rep${aliases: no_aliases, 
	            id: id,
	            key: -2*i-1, 
		    sort: so,
		    str: identifier$id2s(id) || ":" || sort$unparse(so)})
	end make_internal
    
    
    % Returns "true" if "v" is an internal variable.
    
    is_internal = proc (v: cvt) returns (bool)
	return(alias_type$is_none(v.aliases) cand 
	       identifier$is_internal_variable(v.id))
	end is_internal
    
    
    % Returns the variable alias for "v".  Signals "none" if "v" is an internal
    % variable and therefore has no alias.
    
    get_alias = proc (v: cvt) returns (variable) signals (none)
	return(alias_type$value_exists(v.aliases).alias)
	   except when wrong_tag: signal none end
	end get_alias
    
    
    % Returns "true" if "v" was created as an alias by "variable$create".  In
    % this case, "v.alias" is the variable that was returned by
    % "variable$create".
    
    is_alias = proc (v: cvt) returns (bool)
	return(alias_type$value_exists(v.aliases).is_alias)
	   except when wrong_tag: return(false) end
	end is_alias
    
    
    % Returns the constant alias for "v".  Signals "none" if "v" is an internal
    % variable and has no alias.  NOTE: This procedure should be called only by
    % "operator$v2c".  All other procedures should invoke "operator$v2c"
    % instead of "variable$make_constant".
    
    make_constant = proc (v: cvt) returns (operator) signals (none)
	return(alias_type$value_exists(v.aliases).constant)
	   except when wrong_tag: signal none end
	end make_constant
    
    
    % Returns a variable of sort "so" that does not occur in "vars" and that
    % has an identifier that is not overloaded by other variable or constant
    % identifiers in "stab".  Enters the new variable in "stab", but does not
    % commit the change.

    different = proc (so: sort, vars: var_set, stab: symtab) returns (variable)
        head: string := psort$abbreviate(so, 1)
	id: identifier := identifier$make_simple(head)
	n: int := 0
	while true do
	    begin
		for v: variable in var_set$elements(vars) do
		    if id = down(v).id then exit used end
		    end
		v: variable := symtab$lookup_var_id(stab, id)
		   except when ambiguous, operator: exit used
			  when missing:
			       v := variable${id: id, sort: so}
			       return(symtab$enter_var(stab, v))
			  end
		if v.sort = so then return(v) end
		end except when used: end
	    n := n + 1
	    id := identifier$make_simple(head || int$unparse(n))
	    end
	end different


    % Reads and returns a (possibly qualified) variable in "stab" from "scan".
    % Writes a message to "scan", and signals "error", if "scan" does not start
    % with an unambiguous representation for a variable in "stab".
    
    read = proc (scan: scanner, stab: symtab) returns (variable) 
	     signals (error)
	return(pvariable$read(scan, stab))
	   resignal error
	end read

    
    % Prettyprints "v" on "p".
    
    print = proc (p: printer, v: variable, stab: symtab)
	pvariable$print(p, v, stab)
        end print

    
    % Returns a prettyprinted string representation of "v".  Uses the current
    % value of the "display-mode" setting to determine whether to qualify "v".
    
    unparse = proc (v: variable) returns (string)
	return(unparse_item_with_ids[variable](v))
	end unparse
    

    % The following procedures impose an ordering on variables.  This ordering
    % is used when alphabetizing lists of variables for output and when
    % flattening the arguments of AC and commutative operators.

    lt = proc (v1, v2: cvt) returns (bool)
	return(v1.str < v2.str)
	end lt

    le = proc (v1, v2: cvt) returns (bool)
	return(v1.str <= v2.str)
	end le

    gt = proc (v1, v2: cvt) returns (bool)
	return(v1.str > v2.str)
	end gt

    ge = proc (v1, v2: cvt) returns (bool)
	return(v1.str >= v2.str)
	end ge

    
    % Returns "true" iff "v1" and "v2" represent the same variable.

    equal = proc (v1, v2: cvt) returns (bool)
	if v1 = v2 then return(true) end % Redundant, but fast check
	k1: int := v1.key
	k2: int := v2.key
	if k1 ~= 0 cand k2 ~= 0
	    then return(k1 = k2)
	    else return(v1.str = v2.str)
	    end
	% NOTE: We need to check "op1.str = op2.str" even if only one of "k1"
	% and "k2" is nonzero because system$has_var constructs a variable
	% without entering it into the symbol table.
	end equal

    
    % Returns "true" iff "v1" and "v2" represent the same variable.
    
    similar = proc (v1, v2: cvt) returns (bool)
	% Checking record equality is a fast way of finding similar records.
	if v1 = v2 then return(true) end
	return(v1.str = v2.str)
	end similar
    
    
    % Returns "v", which is immutable.

    copy = proc (v: cvt) returns (cvt)
	return(v)
	end copy

    
    % Necessary for "gc_dump".

    _gcd = proc (x: cvt, tab: gcd_tab) returns (int)
	return(rep$_gcd(x, tab))
	end _gcd


    decode = proc (s: istream) returns (variable)
    		signals (end_of_file, not_possible(string))
	begin
	   if decode_all then
	      id: identifier := identifier$decode(s)
	      srt: sort := sort$decode(s)
	      key: int := int$decode(s)
	      v: variable := variable${id: id, sort: srt}
	      v.key := key
	      return(v)
	      end
	   return(decode_map[int$decode(s)])
	  end resignal end_of_file, not_possible
	end decode

    encode = proc (v: cvt, s: istream) signals (not_possible(string))
	if v.key <= 0 then signal failure("variable$encode: key <= 0") end
	begin
	   if encode_all then
	      identifier$encode(v.id, s)
	      sort$encode(v.sort, s)
	      end
	   int$encode(v.key, s)
	  end resignal not_possible
	end encode

    set_decode_all = proc (m: maybe_var_map)
	decode_all := false
	decode_map := maybe_var_map$value(m)
	  except when wrong_tag:
	              decode_map := var_map$new(1)
		      decode_all := true
		 end
	end set_decode_all

    set_encode_all = proc (b: bool)
	encode_all := b
	end set_encode_all

    end variable
