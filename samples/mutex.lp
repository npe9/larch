% Proof that the arbiter tree ensures mutual exclusion
% See arbiter.doc for background information.

set log mutex
set script mutex
clear
set trace 0

% Axioms for the natural numbers under addition

set name nat
declare sort Nat
declare variables i, j: Nat
declare operators
  0 :     -> Nat
  s : Nat -> Nat
  ..
assert
  s(i) = s(j) <=> i = j;
  0 ~= s(i)
  ..


% Axioms for trees

set name tree
declare sort Node
declare variables x, y, z: Node
declare operators
  root  :      -> Node
  L     : Node -> Node
  R     : Node -> Node
  level : Node -> Nat
  ..

assert 
  sort Node generated by root, L, R;
  level(root) = 0;
  level(L(x)) = s(level(x));
  level(R(x)) = s(level(x))
  ..


% Axioms for arbiter

set name invariant
declare operators gr, req, Inv, childMutex, childHas, parentAuth: Node -> Bool
assert
   Inv(x)        <=> childMutex(x) /\ (childHas(x) => parentAuth(x));
   childMutex(x) <=> ~(gr(L(x)) /\ gr(R(x)));
   childHas(x)   <=> gr(L(x)) \/ gr(R(x));
   parentAuth(x) <=> gr(x) /\ req(x);
   Inv(x)
..

set name mutex
set proof-method normalization
prove level(y) = level(z) /\ gr(y) /\ gr(z) => y = z
  resume by induction on y
  resume by induction on z   % To prove basis of induction on y
  resume by induction on z   % To prove first induction step of induction on y
    resume by case yc = zc
      resume by =>
       critical-pairs *Hyp with *
    resume by case yc = zc
      resume by =>
       critical-pairs *Hyp with *
  resume by induction on z   % To prove second induction step of induction on y
    resume by case yc = zc
      resume by =>
       critical-pairs *Hyp with *
    resume by case yc = zc
      resume by =>
       critical-pairs *Hyp with *
  qed
statistics
